<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Multi-Model Weather Picker • Open-Meteo</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" defer></script>

  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js" defer></script>

  <!-- SheetJS for XLSX export -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js" defer></script>

  <!-- html2canvas + jsPDF for PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" defer></script>

  <style>
    :root { color-scheme: dark; }

    body {
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
      background:#0e1116;
      color:#e6e6e6;
      --header-h:64px;
      padding-top:var(--header-h);
    }

    header{
      display:flex;
      flex-wrap:wrap;
      gap:8px 12px;
      align-items:center;
      padding:10px 12px;
      border-bottom:1px solid #222;
      position:fixed;
      top:0; left:0; right:0;
      background:#0e1116;
      z-index:1000;
    }

    header h1 {
      font-size:17px;
      margin:0;
      font-weight:600;
      letter-spacing:0.2px;
      white-space:nowrap;
    }

    header .small {
      flex:1 1 auto;
      min-width:200px;
    }

    .container {
      display:grid;
      grid-template-columns:360px 1fr;
      gap:12px;
      padding:12px;
      max-width:1440px;
      margin:0 auto;
    }

    #map {
      height:440px;
      border-radius:12px;
      overflow:hidden;
      border:1px solid #222;
    }

    .panel {
      background:#121722;
      border:1px solid #202636;
      border-radius:12px;
      padding:10px;
      box-shadow:0 0 0 1px #000 inset;
    }

    .panel h2 {
      font-size:14px;
      font-weight:700;
      letter-spacing:0.3px;
      margin:0 0 6px 0;
      color:#bcdcff;
    }

    .small { font-size:12px; color:#b0b8c7; }
    .muted { color:#8fa3c0; }

    .row {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }

    label {
      font-size:12px;
      color:#cfd6e6;
    }

    select,
    input[type="number"],
    input[type="date"],
    input[type="time"],
    button {
      background:#0f1420;
      color:#e6e6e6;
      border:1px solid #283041;
      border-radius:8px;
      padding:7px 9px;
      font:inherit;
    }

    button.primary {
      background:#2b5cff;
      border-color:#2b5cff;
      color:white;
      font-weight:600;
    }

    button.ghost {
      background:#11151f;
      border-color:#2a3347;
      color:#cfd6e6;
    }

    .chips {
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin:6px 0;
    }

    .chip {
      background:#1a2030;
      border:1px solid #2a3347;
      border-radius:999px;
      padding:3px 7px;
      font-size:12px;
      display:inline-flex;
      align-items:center;
      gap:4px;
    }

    .loc-list {
      max-height:160px;
      overflow:auto;
      border:1px dashed #2a3347;
      padding:6px;
      border-radius:8px;
      margin-top:6px;
      background:#101521;
    }

    .loc-item {
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:3px 4px;
      border-bottom:1px dashed #222c40;
      font-size:12px;
    }

    .loc-item:last-child { border-bottom:none; }

    .grid {
      display:grid;
      grid-template-columns: repeat(2, minmax(260px,1fr));
      gap:10px;
    }

    .grid-3 {
      display:grid;
      grid-template-columns: repeat(3, minmax(260px,1fr));
      gap:10px;
    }

    details {
      border:1px solid #1f2636;
      border-radius:8px;
      padding:5px 7px;
    }

    details summary {
      cursor:pointer;
      color:#c8d7ff;
      font-weight:600;
      font-size:12px;
    }

    table {
      width:100%;
      border-collapse:collapse;
      font-size:12px;
    }

    th, td {
      border-bottom:1px solid #1d2536;
      padding:6px 7px;
      text-align:right;
    }

    th:first-child, td:first-child {
      text-align:left;
    }

    .section-title {
      margin:10px 0 6px 0;
      font-weight:700;
      color:#bcdcff;
      font-size:13px;
    }

    .card {
      background:#121722;
      border:1px solid #202636;
      border-radius:12px;
      padding:7px;
    }

    .badge {
      font-size:11px;
      padding:2px 6px;
      border:1px solid #2a3347;
      border-radius:6px;
      background:#192235;
    }

    .footer {
      padding:10px;
      font-size:11px;
      color:#8aa;
      text-align:center;
      border-top:1px solid #222;
    }

    .status-chip {
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size:11px;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid #2a3347;
      background:#192235;
      margin:3px 4px 0 0;
    }

    .ok  { border-color:#1e8f5a; background:#10261c; color:#9be5b7; }
    .no  { border-color:#8f6b1e; background:#261d10; color:#e5d09b; }
    .err { border-color:#8f1e1e; background:#261010; color:#e59b9b; }

    .profile-row {
      display:flex;
      gap:8px;
      align-items:stretch;
    }

    .profile-left  { flex:0 0 56%; min-width:260px; height:300px; }
    .profile-right {
      flex:0 0 34%;
      min-width:220px;
      height:300px;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:flex-start;
      padding:10px;
      border:1px solid #202636;
      border-radius:12px;
      background:#121722;
    }

    .tabs {
      background:#121722;
      border:1px solid #202636;
      border-radius:12px;
    }

    .tab-bar {
      display:flex;
      gap:6px;
      padding:6px;
      border-bottom:1px solid #202636;
      flex-wrap:nowrap;
      overflow-x:auto;
      white-space:nowrap;
      -webkit-overflow-scrolling:touch;
    }

    .tab-btn {
      background:#151b28;
      border:1px solid #2a3347;
      color:#cfd6e6;
      padding:5px 9px;
      border-radius:8px;
      cursor:pointer;
      font-size:12px;
      flex:0 0 auto;
    }

    .tab-btn.active {
      background:#2b5cff;
      border-color:#2b5cff;
      color:#fff;
    }

    .tab-content { padding:8px; }
    .tab-pane { display:none; }
    .tab-pane.active { display:block; }

    .table-wrap {
      max-height:52vh;
      overflow:auto;
      overflow-x:auto;
      border:1px solid #2a2f3a;
      border-radius:10px;
      -webkit-overflow-scrolling:touch;
    }

    .table {
      width:100%;
      border-collapse:collapse;
      table-layout:fixed;
      font-size:clamp(12px, 0.95vw, 14px);
      line-height:1.25;
    }

    .table th, .table td {
      padding:5px 7px;
      border-bottom:1px solid rgba(255,255,255,0.06);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .table thead th {
      position:sticky;
      top:0;
      z-index:1;
      text-align:left;
      background:linear-gradient(0deg, rgba(0,0,0,0.0), rgba(0,0,0,0.0)) , #151922;
      backdrop-filter:saturate(120%) blur(2px);
    }

    .heat {
      width:100%;
      border-collapse:collapse;
      font-size:12px;
    }

    .heat th, .heat td {
      border-bottom:1px solid #1d2536;
      padding:6px 7px;
      text-align:right;
    }

    .heat th:first-child, .heat td:first-child {
      text-align:left;
      position:sticky;
      left:0;
      background:#121722;
    }

    .cell {
      color:#fff;
      border-radius:4px;
      padding:2px 6px;
      display:inline-block;
      min-width:48px;
      text-align:center;
    }

    .legend {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin:4px 0 0 0;
      font-size:11px;
    }

    .era-year-row{
      border:1px dashed #2a3347;
      border-radius:8px;
      padding:7px;
      margin:6px 0;
    }

    .era-year-head{
      display:flex;
      align-items:center;
      gap:8px;
      margin-bottom:5px;
    }

    /* ---------- Responsive tweaks ---------- */

    @media (max-width:1100px){
      .container {
        grid-template-columns:1fr;
        padding:8px;
        gap:8px;
      }
      #map { height:340px; }
      .profile-row {
        flex-direction:column;
      }
      .profile-left,
      .profile-right {
        flex:0 0 auto;
        width:100%;
        height:260px;
      }
    }

    @media (max-width:900px){
      #map { height:300px; }
      header {
        padding:8px 8px;
      }
      header h1 {
        font-size:16px;
      }
    }

    @media (max-width:600px){
      body {
        padding-top:calc(var(--header-h) + 4px);
      }
      #map { height:230px; }
      .panel {
        padding:8px;
      }
      .card {
        padding:6px;
      }
      .section-title {
        font-size:12px;
        margin-top:8px;
      }
      .profile-left,
      .profile-right {
        height:auto;
        min-height:220px;
      }
      /* Make main buttons full-width on small screens */
      .panel button.primary,
      .panel button.ghost {
        width:100%;
      }
      .row {
        gap:6px;
      }
      /* Slightly shorter charts on phones */
      [id^="chart_"] {
        height:220px !important;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Multi-Model Forecast Picker — Open-Meteo</h1>
    <div class="small">Pick points on the map, choose models & variables, then compare time-series, climatologies and profiles.</div>
    <div style="margin-left:auto" class="small">
      Units:
      <span class="badge">°C</span>
      <span class="badge">kn</span>
      <span class="badge">mm</span>
      <span class="badge">hPa</span>
    </div>
  </header>

  <div class="container">
    <!-- Controls -->
    <div class="panel">
      <h2>1) Pick Locations</h2>
      <div id="map"></div>
      <div class="small" style="margin-top:4px;">Tap the map to add locations. Drag to move. Tap a marker to remove.</div>
      <div class="loc-list" id="locList"></div>

      <h2 style="margin-top:8px">2) Models & Period</h2>
      <div class="row">
        <label>Forecast days (1–10):
          <input type="number" id="days" min="1" max="10" value="1" style="width:80px">
        </label>
      </div>

      <details open style="margin-top:6px;">
        <summary>Choose forecast models</summary>
        <div class="chips" id="models"></div>
        <div class="small muted" style="margin-top:4px;">
          Tip: Mix global + regional. If a model has no coverage for a point, it will be skipped.
        </div>
      </details>

      <!-- HISTORICAL ERA: ERA5 -->
      <div class="section-title" style="margin-top:8px">Historical (ERA5 Reanalysis)</div>
      <div class="row small">
        <label><input type="checkbox" id="era5_toggle"> Include ERA5 historical</label>
      </div>
      <div class="row small" id="era5_dates" style="gap:8px; align-items:center; margin-top:4px;">
        <label>Start:
          <input type="date" id="era5_start" />
        </label>
        <label>End:
          <input type="date" id="era5_end" />
        </label>
        <span class="muted">Most recent days may not yet be in the archive.</span>
      </div>

      <!-- ERA5 YEAR PICKER -->
      <div class="row small" id="era5_years_row" style="gap:6px; align-items:center; margin-top:4px;">
        <div id="era5_years_box" class="chips"></div>
        <button class="ghost" type="button" id="era5_years_all">All</button>
        <button class="ghost" type="button" id="era5_years_none">None</button>
      </div>
      <div class="small muted">
        Pick years within the date span. If none are picked, the full span is used.
      </div>

      <!-- ERA5 MONTHS PER YEAR -->
      <div id="era5_months_box" style="margin-top:4px;"></div>
      <div class="small muted">
        Toggle months per selected year. Default: all months in each year.
      </div>

      <!-- TIME OF DAY FILTER -->
      <div class="section-title" style="margin-top:8px">Time-of-day filter</div>
      <div class="row small">
        <label>Between
          <input type="time" id="tod_from" value="09:00" style="width:110px">
        </label>
        <label>and
          <input type="time" id="tod_to" value="18:00" style="width:110px">
        </label>
        <label><input type="checkbox" id="tod_enable"> Apply filter</label>
      </div>
      <div class="small muted">
        Applied client-side for all datasets. For single-day ERA ranges we also hint it to the server.
      </div>

      <h2 style="margin-top:8px">3) Variables</h2>
      <div class="small">
        10 m wind (speed & direction) is always included. Add surface & wave variables:
      </div>
      <div class="grid" style="margin-top:4px;">
        <div>
          <div class="section-title">Surface</div>
          <label><input type="checkbox" class="var" value="temperature_2m" checked> Temperature (2 m)</label><br>
          <label><input type="checkbox" class="var" value="precipitation" checked> Precipitation</label><br>
          <label><input type="checkbox" class="var" value="wind_gusts_10m" checked> Wind Gusts (10 m)</label><br>
          <label><input type="checkbox" class="var" value="pressure_msl" checked> Sea-level Pressure</label><br>
          <label><input type="checkbox" class="var" value="cloud_cover" checked> Cloud Cover Total</label><br>
          <label><input type="checkbox" class="var" value="boundary_layer_height" checked> Boundary Layer Height</label><br>

          <div class="section-title" style="margin-top:6px;">Marine</div>
          <label><input type="checkbox" id="marine_swh" checked> Significant Wave Height (m)</label>
          <div class="small muted">(Marine API; max 7 forecast days)</div>
        </div>
      </div>

      <div class="section-title">Upper-air pressure levels</div>
      <div class="small">
        For these levels, we fetch T (°C), TWS (kn) & TWD (°).
      </div>
      <div class="chips" id="plChips"></div>

      <div class="row" style="margin-top:8px">
        <button class="primary" id="runBtn">Fetch Forecasts</button>
        <button class="ghost" id="pdfBtn">Export Full Report (PDF)</button>
      </div>
      <div id="progress" class="small muted" style="margin-top:6px; display:none;">
        <div style="height:8px;background:#1f2636;border-radius:6px;overflow:hidden;">
          <div id="progressBar" style="height:8px;width:0%;background:#2b5cff;"></div>
        </div>
        <div id="progressText" style="margin-top:4px;"></div>
      </div>
    </div>

    <!-- Results: tabbed per location -->
    <div class="tabs">
      <div class="tab-bar" id="tabBar"></div>
      <div class="tab-content" id="tabContent"></div>
    </div>
  </div>

  <div class="footer">
    Data © Open-Meteo & model providers. Visualisation by Opposite Tack. Free for non-commercial use.
  </div>

<script>
/* ---------- Layout / header padding & duplicate map guard ---------- */
document.addEventListener('DOMContentLoaded', () => {
  const hdr = document.querySelector('header');
  const setPad = () => {
    if (!hdr) return;
    document.body.style.setProperty('--header-h', hdr.offsetHeight + 'px');
  };
  setPad();
  window.addEventListener('resize', setPad);
});

// In case something injects extra #map panels, prune them
const pruneDupMaps = () => {
  const maps = document.querySelectorAll('#map');
  for (let i = 1; i < maps.length; i++) {
    (maps[i].closest('.panel') || maps[i]).remove();
  }
};
new MutationObserver(pruneDupMaps).observe(document.body, { childList: true, subtree: true });

/* ---------- Model mapping ---------- */
const MODEL_CODES = {
  "ECMWF IFS 0.25": "ecmwf_ifs025",
  "DWD ICON EU": "icon_eu",
  "Meteo-France ARPEGE World": "arpege_world",
  "Meteo-France ARPEGE Europe": "arpege_europe",
  "Meteo-France AROME France": "arome_france",
  "Meteo-France AROME France HD": "arome_france_hd",
  /* "UKMO UKV 2km": "ukmo_uk_deterministic_2km",*/
  "UKMO Seamless": "ukmo_seamless",
  "NCEP GFS Global Seamless": "gfs_seamless",
  "NCEP HRRR U.S. Conus": "hrrr_conus",
  "NCEP NAM U.S. Conus": "nam_conus",
  "ItaliaMeteo ARPAE ICON 2I": "arpae_icon_2i"
};

const PRESSURE_LEVELS = [975,950,925,900,850,700,600,500,400,300,250,200,150];

function buildHourlyVars(s){
  return ["wind_speed_10m","wind_direction_10m"].concat(s);
}

function buildPressureLevelVars(levels){
  const v = [];
  levels.forEach(p => {
    v.push(`temperature_${p}hPa`, `windspeed_${p}hPa`, `winddirection_${p}hPa`);
  });
  return v;
}

/* ---------- Helper functions ---------- */
function hhmmToMin(hhmm){
  if (!hhmm) return null;
  const [h, m] = hhmm.split(':').map(Number);
  return (isNaN(h) || isNaN(m)) ? null : (h*60 + m);
}

function buildTodIndexMask(timeArr, fromMin, toMin){
  if (!Array.isArray(timeArr) || fromMin==null || toMin==null) return null;
  const wrap = toMin < fromMin;
  return timeArr.map((iso) => {
    const d = new Date(iso);
    const mins = d.getHours()*60 + d.getMinutes();
    return wrap ? (mins >= fromMin || mins <= toMin) : (mins >= fromMin && mins <= toMin);
  });
}

function applyMaskToRecord(rec, mask){
  if (!rec || !Array.isArray(mask)) return rec;
  const filt = (arr) => Array.isArray(arr) ? arr.filter((_,i)=>mask[i]) : arr;
  const out = { ...rec };
  out.time = filt(rec.time);
  [
    'wind_speed_10m','wind_direction_10m','temperature_2m','precipitation',
    'wind_gusts_10m','pressure_msl','cloud_cover','boundary_layer_height',
    'wave_height','wave_time'
  ].forEach(k => {
    if (k in rec) out[k] = filt(rec[k]);
  });
  if (rec.pl){
    out.pl = {};
    Object.keys(rec.pl).forEach(p=>{
      const obj = rec.pl[p] || {};
      out.pl[p] = { ws: filt(obj.ws), wd: filt(obj.wd), tt: filt(obj.tt) };
    });
  }
  return out;
}

function listYearsBetween(startStr, endStr){
  if (!startStr || !endStr) return [];
  const ys = parseInt(startStr.slice(0,4), 10);
  const ye = parseInt(endStr.slice(0,4), 10);
  if (isNaN(ys) || isNaN(ye) || ye < ys) return [];
  const out = [];
  for (let y=ys; y<=ye; y++) out.push(y);
  return out;
}

function monthName(m){
  return ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][m-1];
}

function lastDayOfMonth(y,m){
  return new Date(y, m, 0).getDate(); // m: 1-12
}

function renderEraYearChips(years){
  const box = document.getElementById('era5_years_box');
  if (!box) return;
  if (!years.length){
    box.innerHTML = "<span class='small muted'>Select start & end dates to choose years…</span>";
    return;
  }
  box.innerHTML = years
    .map(y => `<label class="chip"><input type="checkbox" class="era5-year" value="${y}" checked> ${y}</label>`)
    .join('');
}

function renderEraMonthsPerYear(){
  const cont = document.getElementById('era5_months_box');
  if (!cont) return;

  const years = [...document.querySelectorAll('.era5-year')]
    .map(cb => ({ y: parseInt(cb.value,10), on: cb.checked }));

  cont.innerHTML = '';
  years.filter(o => o.on).forEach(({y}) => {
    const row = document.createElement('div');
    row.className = 'era-year-row';
    row.innerHTML = `
      <div class="era-year-head">
        <strong>${y}</strong>
        <button type="button" class="ghost era-month-all" data-year="${y}">All</button>
        <button type="button" class="ghost era-month-none" data-year="${y}">None</button>
      </div>
      <div class="chips" id="era-months-${y}">
        ${Array.from({length:12},(_,i)=>{
          const m=i+1;
          return `<label class="chip"><input type="checkbox" class="era5-month" data-year="${y}" value="${m}" checked> ${monthName(m)}</label>`;
        }).join('')}
      </div>`;
    cont.appendChild(row);
  });

  // Wire All/None
  cont.querySelectorAll('.era-month-all').forEach(btn => {
    btn.addEventListener('click', () => {
      const y = btn.dataset.year;
      cont.querySelectorAll(`.era5-month[data-year="${y}"]`).forEach(cb => cb.checked = true);
    });
  });
  cont.querySelectorAll('.era-month-none').forEach(btn => {
    btn.addEventListener('click', () => {
      const y = btn.dataset.year;
      cont.querySelectorAll(`.era5-month[data-year="${y}"]`).forEach(cb => cb.checked = false);
    });
  });
}

function readSelectedEraYears(){
  return [...document.querySelectorAll('.era5-year:checked')]
    .map(el => parseInt(el.value,10))
    .filter(v => !isNaN(v));
}

function readSelectedEraMonthsMap(){
  const map = new Map();
  const years = readSelectedEraYears();
  years.forEach(y => {
    const chips = [...document.querySelectorAll(`.era5-month[data-year="${y}"]`)];
    if (!chips.length){
      map.set(y, Array.from({length:12},(_,i)=>i+1));
    } else {
      const ms = chips
        .filter(cb => cb.checked)
        .map(cb => parseInt(cb.value,10))
        .filter(v => !isNaN(v));
      map.set(y, ms.length ? ms : []);
    }
  });
  return map;
}

function setupEraYearChipWiring(){
  const s = document.getElementById('era5_start');
  const e = document.getElementById('era5_end');
  const btnAll  = document.getElementById('era5_years_all');
  const btnNone = document.getElementById('era5_years_none');

  function refreshYears(){
    renderEraYearChips(listYearsBetween(s.value, e.value));
    renderEraMonthsPerYear();
    document.querySelectorAll('.era5-year').forEach(cb => {
      cb.addEventListener('change', renderEraMonthsPerYear);
    });
  }

  if (s) s.addEventListener('change', refreshYears);
  if (e) e.addEventListener('change', refreshYears);

  if (btnAll) {
    btnAll.addEventListener('click', () => {
      document.querySelectorAll('.era5-year').forEach(cb => cb.checked = true);
      renderEraMonthsPerYear();
    });
  }

  if (btnNone) {
    btnNone.addEventListener('click', () => {
      document.querySelectorAll('.era5-year').forEach(cb => cb.checked = false);
      renderEraMonthsPerYear();
    });
  }

  refreshYears();
}
document.addEventListener('DOMContentLoaded', setupEraYearChipWiring);

function contiguousIsoRangeIfSingleDay(dateStr, fromHHMM, toHHMM){
  if (!dateStr || !fromHHMM || !toHHMM) return [null, null];
  return [`${dateStr}T${fromHHMM}`, `${dateStr}T${toHHMM}`];
}

function maybeApplyHourWindow(u, startISO, endISO){
  if (!startISO || !endISO) return;
  u.searchParams.set('start_hour', startISO);
  u.searchParams.set('end_hour', endISO);
}

/* ---------- Map ---------- */
document.addEventListener('DOMContentLoaded', () => {
  const map = L.map('map', { zoomControl: true }).setView([54.5, -2.5], 6);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap'
  }).addTo(map);

  let markers = [];
  let idSeq = 1;

  map.on('click', (e) => {
    const m = L.marker(e.latlng, { draggable:true }).addTo(map);
    const loc = { marker: m, lat: e.latlng.lat, lon: e.latlng.lng, id: idSeq++ };
    markers.push(loc);

    m.on('dragend', () => {
      loc.lat = m.getLatLng().lat;
      loc.lon = m.getLatLng().lng;
      renderLocList();
    });

    m.on('click', () => {
      m.remove();
      markers = markers.filter(x => x !== loc);
      renderLocList();
    });

    renderLocList();
  });

  function renderLocList(){
    const box = document.getElementById('locList');
    if (!markers.length) {
      box.innerHTML = '<div class="small muted">No locations yet. Tap the map to add markers.</div>';
      return;
    }
    box.innerHTML = markers.map(m =>
      `<div class='loc-item'><span>Lat ${m.lat.toFixed(3)}, Lon ${m.lon.toFixed(3)}</span><span class='muted'>#${m.id}</span></div>`
    ).join('');
  }
  renderLocList();

  /* ---------- Controls for models & pressure levels ---------- */
  const modelsDiv = document.getElementById('models');
  Object.keys(MODEL_CODES).forEach(name => {
    const id = `mdl_${MODEL_CODES[name]}`;
    const el = document.createElement('label');
    el.className = 'chip';
    el.innerHTML = `<input type='checkbox' class='model' id='${id}' value='${MODEL_CODES[name]}'> ${name}`;
    modelsDiv.appendChild(el);
  });

  const plDiv = document.getElementById('plChips');
  PRESSURE_LEVELS.forEach(p => {
    const span = document.createElement('label');
    span.className = 'chip';
    span.innerHTML = `<input type='checkbox' class='pl' value='${p}' checked> ${p} hPa`;
    plDiv.appendChild(span);
  });

  /* ---------- Tabs ---------- */
  const tabBar = document.getElementById('tabBar');
  const tabContent = document.getElementById('tabContent');
  const paneCharts = {};

  function addTab(loc){
    const tabId = `tab-${loc.id}`;
    const paneId = `pane-${loc.id}`;

    const btn = document.createElement('button');
    btn.className = 'tab-btn';
    btn.id = tabId;
    btn.innerText = `#${loc.id}  ${loc.lat.toFixed(2)}, ${loc.lon.toFixed(2)}`;
    btn.addEventListener('click', () => activateTab(loc.id));
    tabBar.appendChild(btn);

    const pane = document.createElement('div');
    pane.className = 'tab-pane';
    pane.id = paneId;
    tabContent.appendChild(pane);

    return pane;
  }

  function activateTab(locId){
    [...tabBar.children].forEach(b => b.classList.toggle('active', b.id === `tab-${locId}`));
    [...tabContent.children].forEach(p => p.classList.toggle('active', p.id === `pane-${locId}`));
    (paneCharts[locId] || []).forEach(divId => {
      const el = document.getElementById(divId);
      if (el && window.Plotly) Plotly.Plots.resize(el);
    });
  }

  /* ---------- Table autosize helper ---------- */
  function autosizeTable(tableEl) {
    if (!tableEl || !tableEl.tHead || !tableEl.tHead.rows.length) return;
    const cols = tableEl.tHead.rows[0].cells.length;

    let cg = tableEl.querySelector('colgroup');
    if (!cg) {
      cg = document.createElement('colgroup');
      tableEl.insertBefore(cg, tableEl.firstChild);
    }
    cg.innerHTML = '';
    const pct = (100 / cols);
    for (let i = 0; i < cols; i++) {
      const col = document.createElement('col');
      col.style.width = pct + '%';
      cg.appendChild(col);
    }
  }

  const _debounce = (fn, d=120) => {
    let t;
    return (...a) => {
      clearTimeout(t);
      t = setTimeout(() => fn(...a), d);
    };
  };

  const resizeTables = _debounce(() => {
    document.querySelectorAll('table.table').forEach(autosizeTable);
  }, 120);

  window.addEventListener('resize', resizeTables);

  /* ---------- Plotly base layouts ---------- */
  const BASE_PLOTLY_LAYOUT = {
    template: 'plotly_dark',
    paper_bgcolor: '#121722',
    plot_bgcolor: '#0f1420',
    hovermode: 'x unified',
    dragmode: false,
    margin: { l: 56, r: 24, t: 54, b: 60 },
    font: {
      family: 'Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif',
      size: 12,
      color: '#dfe7f5'
    },
    xaxis: {
      type: 'date',
      automargin: true,
      gridcolor: '#1f2636',
      linecolor:'#2a3347',
      ticks:'outside',
      tickcolor:'#2a3347',
      showspikes:true,
      spikemode:'across',
      spikesnap:'cursor',
      spikethickness:1
    },
    yaxis: {
      automargin: true,
      gridcolor: '#1f2636',
      linecolor:'#2a3347',
      ticks:'outside',
      tickcolor:'#2a3347',
      rangemode:'tozero'
    },
    legend: {
      orientation:'h',
      x:0, y:-0.2,
      xanchor:'left',
      yanchor:'top',
      bgcolor:'rgba(0,0,0,0)'
    },
    title: {
      x:0,
      xanchor:'left',
      font:{ size:14, color:'#cfe0ff' }
    }
  };

  const PLOTLY_CONFIG = { responsive:true, displaylogo:false };

  function layout(title){
    return {
      ...BASE_PLOTLY_LAYOUT,
      title:{ ...BASE_PLOTLY_LAYOUT.title, text:title }
    };
  }

  function layoutPmsl(title){
    const l = layout(title);
    l.yaxis = { ...l.yaxis, rangemode:'normal', range:[800,1100] };
    return l;
  }

  // New: layout for ERA climatology (x = day-of-month)
  function layoutClim(title, xTitle){
    const l = layout(title);
    l.xaxis = {
      ...l.xaxis,
      type:'linear',
      title: xTitle || 'Day of month',
      dtick: 1
    };
    return l;
  }

  function layoutPmslClim(title){
    const l = layoutClim(title, 'Day of month');
    l.yaxis = { ...l.yaxis, rangemode:'normal', range:[800,1100] };
    return l;
  }

  function renderPlotOrMsg(divId, traces, lay){
    const el = document.getElementById(divId);
    if (!el) return;
    if (!traces || !traces.length || !window.Plotly){
      el.innerHTML = "<div class='small muted'>No data returned for the selected models/area/variables.</div>";
      return;
    }
    traces.forEach(t => {
      t.line = t.line || {};
      if (t.line.width == null) t.line.width = 2;
      t.cliponaxis = true;
    });
    Plotly.newPlot(divId, traces, lay, PLOTLY_CONFIG);
  }

  /* ---------- Colors & stats ---------- */
  function colorForKnots(kn){
    if (kn === '' || kn == null || isNaN(kn)) return '#444';
    if (kn < 5)  return '#3d6cff';
    if (kn < 10) return '#1fa35b';
    if (kn < 15) return '#d2b100';
    if (kn < 20) return '#ff7a00';
    if (kn < 25) return '#e13b2d';
    if (kn < 30) return '#7a1830';
    return '#7d3cff';
  }

  function colorForTempC(tc){
    return colorForKnots(tc);
  }

  function circMeanDeg(arr){
    let sx=0, sy=0, n=0;
    for (const v of arr){
      if (v==null || isNaN(v)) continue;
      const r = v*Math.PI/180;
      sx += Math.cos(r);
      sy += Math.sin(r);
      n++;
    }
    if (!n) return null;
    let ang = Math.atan2(sy,sx)*180/Math.PI;
    if (ang < 0) ang += 360;
    return ang;
  }

  function angDiff(a,b){
    return ((a - b + 540) % 360) - 180;
  }

  // Shared TWS bins (tables + wind rose)
  const TWS_BINS = [0, 5, 10, 15, 20, 25, 30, Infinity];
  const TWS_COLOURS = [
    '#3d6cff',
    '#1fa35b',
    '#d2b100',
    '#ff7a00',
    '#e13b2d',
    '#7a1830',
    '#7d3cff'
  ];

  const TWS_BIN_LABELS = (() => {
    const out = [];
    for (let i = 0; i < TWS_BINS.length; i++) {
      const a = TWS_BINS[i], b = TWS_BINS[i+1];
      out.push(b === Infinity ? `${a}+ kt` : `${a}–${b} kt`);
    }
    return out;
  })();

  function twsBinIndex(kn) {
    if (kn == null || isNaN(kn)) return 0;
    for (let i = 0; i < TWS_BINS.length; i++) {
      const a = TWS_BINS[i], b = TWS_BINS[i+1];
      if (b === Infinity) return (kn >= a) ? i : 0;
      if (kn >= a && kn < b) return i;
    }
    return 0;
  }

  /* ---------- Heat tables ---------- */
  function renderVarMatrixTable(targetEl, timesSorted, modelsWithData, modelSeries, valueGetter, colorGetter, valueFormatter){
    const table = document.createElement('table');
    table.className = 'heat';
    const thead = document.createElement('thead');
    const thr = document.createElement('tr');
    thr.innerHTML = ['Time'].concat(modelsWithData.map(nameOf)).map(h=>`<th>${h}</th>`).join('');
    thead.appendChild(thr);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    timesSorted.forEach(ts => {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${ts}</td>`;
      modelsWithData.forEach(mdl => {
        const v = valueGetter(ts, mdl);
        const disp = valueFormatter ? valueFormatter(v) : (v===''? '' : Number(v).toFixed(1));
        const color = colorGetter ? colorGetter(v, ts, mdl) : null;
        const td = document.createElement('td');
        td.innerHTML = color ? `<span class="cell" style="background:${color}">${disp}</span>` : disp;
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);

    targetEl.innerHTML = '';
    const wrap = document.createElement('div');
    wrap.className = 'table-wrap';
    wrap.appendChild(table);
    targetEl.appendChild(wrap);
  }

  function buildTimesUnion(modelSeries, modelsWithData){
    const allTimes = new Set();
    modelsWithData.forEach(m =>
      (modelSeries[m].time || []).forEach(t => allTimes.add(t))
    );
    return Array.from(allTimes).sort();
  }

  /* ---------- XLSX placeholder ---------- */
  const XLSX_SHEETS = {};

  /* ---------- PDF export ---------- */
  document.getElementById('pdfBtn').addEventListener('click', async () => {
    if (!window.jspdf || !window.html2canvas) {
      alert('PDF libraries not loaded yet. Please try again in a moment.');
      return;
    }
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ unit: 'pt', format: 'a4' });
    const reportEl = document.body;
    const canvas = await html2canvas(reportEl, { scale: 1.5 });
    const imgData = canvas.toDataURL('image/png');
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const ratio = Math.min(pageWidth / canvas.width, pageHeight / canvas.height);
    const w = canvas.width * ratio;
    const h = canvas.height * ratio;
    pdf.addImage(imgData, 'PNG', 0, 0, w, h);
    pdf.save('openmeteo_report.pdf');
  });

  /* ---------- Names ---------- */
  const nameOf  = (m) => (m === 'era5' ? 'ERA5 Reanalysis' : m);
  const labelFor = nameOf;

  /* ---------- Wind rose helpers ---------- */
  function degToBin10(d){
    const x = (d==null || isNaN(d)) ? null : ((d % 360) + 360) % 360;
    return (x==null) ? null : Math.floor(x / 10); // 0..35
  }

  function buildWindSamplesFromSeries(rec){
    const s = [], d = [];
    const sp = rec?.wind_speed_10m || [];
    const dr = rec?.wind_direction_10m || [];
    const n = Math.min(sp.length, dr.length);
    for (let i=0; i<n; i++){
      const v = sp[i], w = dr[i];
      if (v==null || isNaN(v) || w==null || isNaN(w)) continue;
      s.push(Number(v));
      d.push(Number(w));
    }
    return { s, d };
  }

  function concatSamples(list){
    const S = [], D = [];
    list.forEach(({s,d}) => {
      for (let i=0; i<s.length; i++){
        S.push(s[i]);
        D.push(d[i]);
      }
    });
    return { s:S, d:D };
  }

  function binWindsCustom(speeds, dirs){
    const counts = Array.from(
      {length:36},
      () => Array.from({length:TWS_BINS.length}, () => 0)
    );
    const dirTotals = new Array(36).fill(0);

    for (let i = 0; i < speeds.length; i++){
      const s = speeds[i], d = dirs[i];
      const bDir = degToBin10(d);
      if (bDir == null) continue;
      const bSpd = twsBinIndex(s);
      counts[bDir][bSpd] += 1;
      dirTotals[bDir] += 1;
    }

    const dirLabels = Array.from({length:36}, (_,i)=> i*10 + 5);
    return { counts, dirTotals, speedBins: TWS_BIN_LABELS, dirLabels };
  }

  function computeWindStats(speeds, dirs){
    const n = speeds.length;
    if (!n) return { meanTws:null, calmPct:null, highPct25:null, peakPct:null, peakDir:null };

    const CALM_KT = 4;
    const HIGH_KT = 25;

    const calm = speeds.filter(v => v < CALM_KT).length;
    const high = speeds.filter(v => v >= HIGH_KT).length;

    const calmPct   = 100 * calm / n;
    const highPct25 = 100 * high / n;
    const meanTws   = speeds.reduce((a,b)=>a+b,0) / n;

    const bins = new Array(36).fill(0);
    for (let i=0; i<n; i++){
      const b = degToBin10(dirs[i]);
      if (b!=null) bins[b]++;
    }
    let peakIdx = 0;
    for (let i=1; i<36; i++){
      if (bins[i] > bins[peakIdx]) peakIdx = i;
    }
    const peakCnt = bins[peakIdx];
    const peakPct = 100 * peakCnt / n;
    const peakDir = (peakIdx*10 + 5) % 360;

    return { meanTws, calmPct, highPct25, peakPct, peakDir };
  }

  function makeWindRoseTraces(counts, speedBins, dirLabels){
    const traces = [];
    for (let sb = 0; sb < speedBins.length; sb++){
      const r = counts.map(row => row[sb] || 0);
      if (!r.some(v => v > 0)) continue;
      traces.push({
        type: 'barpolar',
        r,
        theta: dirLabels,
        name: speedBins[sb],
        hovertemplate: 'Dir %{theta}°<br>%{r:.1f}%<br>' + speedBins[sb] + '<extra></extra>',
        marker: { color: TWS_COLOURS[sb] }
      });
    }
    return traces;
  }

  function formatPct(x){ return (x==null) ? '—' : `${x.toFixed(1)}%`; }
  function formatKn(x){ return (x==null) ? '—' : `${x.toFixed(1)} kt`; }
  function formatDeg(x){ return (x==null) ? '—' : `${Math.round(x)}°`; }

  /* ---------- New: ERA daily climatology helper ---------- */
  function buildEraClimatology(rec){
    if (!rec || !Array.isArray(rec.time)) return null;

    const buckets = {}; // day -> {tws:[], twd:[], rain:[], t2m:[], pmsl:[]}
    const n = rec.time.length;

    for (let i=0; i<n; i++){
      const iso = rec.time[i];
      if (!iso) continue;
      const d = new Date(iso);
      if (isNaN(d)) continue;
      const day = d.getDate(); // day-of-month

      if (!buckets[day]){
        buckets[day] = { tws:[], twd:[], rain:[], t2m:[], pmsl:[] };
      }
      const b = buckets[day];

      const pushNum = (arr, val) => {
        if (val==null) return;
        const num = Number(val);
        if (!isNaN(num)) arr.push(num);
      };

      pushNum(b.tws,  rec.wind_speed_10m     && rec.wind_speed_10m[i]);
      pushNum(b.twd,  rec.wind_direction_10m && rec.wind_direction_10m[i]);
      pushNum(b.rain, rec.precipitation      && rec.precipitation[i]);
      pushNum(b.t2m,  rec.temperature_2m     && rec.temperature_2m[i]);
      pushNum(b.pmsl, rec.pressure_msl       && rec.pressure_msl[i]);
    }

    const days = Object.keys(buckets)
      .map(x => parseInt(x,10))
      .sort((a,b)=>a-b);

    const out = {
      day: [],
      tws_mean: [], tws_min: [], tws_max: [],
      t2m_mean: [], t2m_min: [], t2m_max: [],
      pmsl_mean: [], pmsl_min: [], pmsl_max: [],
      twd_mean: [],
      rain_mean: []
    };

    const avg = arr => arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : null;
    const min = arr => arr.length ? Math.min(...arr) : null;
    const max = arr => arr.length ? Math.max(...arr) : null;

    days.forEach(day => {
      const b = buckets[day];
      out.day.push(day);

      out.tws_mean.push(avg(b.tws));
      out.tws_min.push(min(b.tws));
      out.tws_max.push(max(b.tws));

      out.t2m_mean.push(avg(b.t2m));
      out.t2m_min.push(min(b.t2m));
      out.t2m_max.push(max(b.t2m));

      out.pmsl_mean.push(avg(b.pmsl));
      out.pmsl_min.push(min(b.pmsl));
      out.pmsl_max.push(max(b.pmsl));

      out.twd_mean.push(circMeanDeg(b.twd));
      out.rain_mean.push(avg(b.rain));
    });

    return out;
  }

  /* ---------- Run button ---------- */
  document.getElementById('runBtn').addEventListener('click', run);

  async function run(){
    const days = Math.max(1, Math.min(10, parseInt(document.getElementById('days').value || '5')));
    if (!markers.length) {
      alert('Add at least one location by tapping the map.');
      return;
    }

    const selectedModels = [...document.querySelectorAll('.model:checked')].map(x => x.value);
    const era5On   = document.getElementById('era5_toggle').checked;

    if (!selectedModels.length && !era5On) {
      alert('Select at least one forecast model or turn on ERA5.');
      return;
    }

    const surfaceVars = [...document.querySelectorAll('.var:checked')].map(x => x.value);
    const levels      = [...document.querySelectorAll('.pl:checked')].map(x => parseInt(x.value));
    const hourly      = buildHourlyVars(surfaceVars).concat(buildPressureLevelVars(levels));
    const includeMarine = document.getElementById('marine_swh').checked;

    const eraStart = document.getElementById('era5_start').value || '';
    const eraEnd   = document.getElementById('era5_end').value   || '';

    const todEnabled = document.getElementById('tod_enable').checked;
    const todFrom    = document.getElementById('tod_from').value;
    const todTo      = document.getElementById('tod_to').value;
    const todFromMin = hhmmToMin(todFrom);
    const todToMin   = hhmmToMin(todTo);

    const eraYearsSelected = readSelectedEraYears();
    const eraMonthsMap     = readSelectedEraMonthsMap();

    function countEraMonthRequests(){
      if (!era5On) return 0;
      if (!eraStart || !eraEnd) return 0;
      if (!eraYearsSelected.length) return 1;
      let c = 0;
      eraYearsSelected.forEach(y => {
        const ms = eraMonthsMap.get(y) || [];
        c += (ms.length ? ms.length : 0);
      });
      return (c === 0) ? 0 : c;
    }

    // Progress bar
    const prog = document.getElementById('progress');
    const bar  = document.getElementById('progressBar');
    const ptxt = document.getElementById('progressText');

    const totalCalls =
      (markers.length * selectedModels.length) +
      (includeMarine ? markers.length : 0) +
      (era5On ? markers.length * Math.max(1, countEraMonthRequests()) : 0);

    let doneCalls = 0;
    function setProgress(){
      const pct = totalCalls ? Math.round(100 * doneCalls / totalCalls) : 0;
      bar.style.width = pct + '%';
      ptxt.textContent = `Downloading models: ${doneCalls}/${totalCalls} (${pct}%)`;
    }
    function inc(){ doneCalls++; setProgress(); }

    prog.style.display = 'block';
    doneCalls = 0;
    setProgress();

    tabBar.innerHTML = '';
    tabContent.innerHTML = '';
    for (const k in XLSX_SHEETS) delete XLSX_SHEETS[k];

    const createdPanes = [];

    for (const loc of markers){
      try {
        const pane = addTab(loc);
        const locContainer = document.createElement('div');
        locContainer.className = 'panel';
        locContainer.innerHTML = `<h2>Location #${loc.id} — ${loc.lat.toFixed(3)}, ${loc.lon.toFixed(3)}</h2>`;
        pane.appendChild(locContainer);

        const statusBar = document.createElement('div');
        statusBar.className = 'small';
        statusBar.style.margin = '4px 0 6px 0';
        statusBar.id = `status_${loc.id}`;
        locContainer.appendChild(statusBar);

        const chartsGrid = document.createElement('div');
        chartsGrid.className = 'grid';
        locContainer.appendChild(chartsGrid);

        const chartIds = ['TWS','TWD','RAIN','T2M','PMSL','SWH'].map(k => `chart_${loc.id}_${k}`);
        paneCharts[loc.id] = chartIds.map(id => id);

        chartIds.forEach(id => {
          const div = document.createElement('div');
          div.className = 'card';
          div.style.minHeight = '260px';
          const label = id.split('_').pop();
          div.innerHTML = `<div class='small muted' style='margin-bottom:4px'>${label}</div><div id='${id}' style='height:240px'></div>`;
          chartsGrid.appendChild(div);
        });

        /* --- Vertical Profile + BLH box --- */
        const profileWrap = document.createElement('div');
        profileWrap.className = 'card';
        profileWrap.style.marginTop = '10px';
        profileWrap.innerHTML = `
          <div class='section-title'>Vertical Profile — TWS & Temp vs Pressure + Boundary Layer Height (GFS)</div>
          <div class='row small'>
            <label>Time index: <input id='prof_idx_${loc.id}' type='number' min='0' value='0' style='width:70px'></label>
            <span class='muted'>Start at 0 for first forecast hour.</span>
          </div>
          <div class="profile-row" style="margin-top:4px;">
            <div id='profile_left_${loc.id}'  class='profile-left'></div>
            <div id='profile_blh_${loc.id}' class='profile-right'>
              <div class='small muted' style="margin-bottom:4px">Boundary Layer Height — GFS</div>
              <div id='blh_value_${loc.id}' style="font-size:28px; font-weight:700;">—</div>
              <div class="small muted">m AGL (boundary_layer_height)</div>
              <div class="small muted" id='blh_meta_${loc.id}' style="margin-top:4px;"></div>
            </div>
          </div>`;
        locContainer.appendChild(profileWrap);
        paneCharts[loc.id].push(`profile_left_${loc.id}`);

        /* --- Wind Rose --- */
        const roseCard = document.createElement('div');
        roseCard.className = 'card';
        roseCard.style.marginTop = '10px';

        const roseSelectId = `rose_sel_${loc.id}`;
        const rosePlotId   = `rose_plot_${loc.id}`;
        const roseTblId    = `rose_tbl_${loc.id}`;
        paneCharts[loc.id].push(rosePlotId);

        roseCard.innerHTML = `
          <div class='section-title'>Wind Rose (10° bins, TWS bins as per tables) & Summary</div>
          <div class='row small' style="align-items:center; gap:8px;">
            <label>Dataset:
              <select id="${roseSelectId}"></select>
            </label>
            <span class="muted">Calm threshold: &lt; 4 kt</span>
          </div>
          <div class="grid" style="margin-top:6px;">
            <div id="${rosePlotId}" style="min-height:320px;"></div>
            <div>
              <table style="width:100%; font-size:12px;">
                <thead><tr><th style="text-align:left;">Metric</th><th style="text-align:right;">Value</th></tr></thead>
                <tbody id="${roseTblId}">
                  <tr><td>Mean TWS</td><td style="text-align:right;">—</td></tr>
                  <tr><td>Peak frequency</td><td style="text-align:right;">—</td></tr>
                  <tr><td>% Calm (&lt;4 kt)</td><td style="text-align:right;">—</td></tr>
                  <tr><td>% &ge;25 kt</td><td style="text-align:right;">—</td></tr>
                  <tr><td>Peak TWD (dir bin)</td><td style="text-align:right;">—</td></tr>
                </tbody>
              </table>
            </div>
          </div>`;
        locContainer.appendChild(roseCard);

        /* --- Data containers --- */
        const modelSeries = {};
        const modelStatus = {};

        /* ----- Forecast models loop ----- */
        for (const mdl of selectedModels){
          try {
            const url = new URL('https://api.open-meteo.com/v1/forecast');
            url.searchParams.set('latitude', loc.lat);
            url.searchParams.set('longitude', loc.lon);
            url.searchParams.set('forecast_days', days);
            url.searchParams.set('timezone', 'auto');
            url.searchParams.set('models', mdl);
            url.searchParams.set('temperature_unit', 'celsius');
            url.searchParams.set('wind_speed_unit', 'kn');
            url.searchParams.set('precipitation_unit', 'mm');
            url.searchParams.set('pressure_unit', 'hPa');
            url.searchParams.set('hourly', hourly.join(','));

            const res = await fetch(url.toString());
            const js  = await res.json();
            inc();

            if (!js || !js.hourly || !js.hourly.time || !js.hourly.time.length){
              modelStatus[mdl] = 'no';
              continue;
            }

            const h = js.hourly;
            const rec = {
              time: h.time || [],
              wind_speed_10m:     h.wind_speed_10m || [],
              wind_direction_10m: h.wind_direction_10m || [],
              temperature_2m:     h.temperature_2m || [],
              precipitation:      h.precipitation || h.rain || [],
              wind_gusts_10m:     h.wind_gusts_10m || [],
              pressure_msl:       h.pressure_msl || [],
              cloud_cover:        h.cloud_cover || h.cloudcover || [],
              boundary_layer_height: h.boundary_layer_height || h.pbl_height || [],
              pl: {}
            };

            for (const p of levels){
              const ws = h[`windspeed_${p}hPa`]     || h[`wind_speed_${p}hPa`]     || [];
              const wd = h[`winddirection_${p}hPa`] || h[`wind_direction_${p}hPa`] || [];
              const tt = h[`temperature_${p}hPa`]   || [];
              rec.pl[p] = { ws, wd, tt };
            }

            if (todEnabled && todFromMin!=null && todToMin!=null){
              const mask = buildTodIndexMask(rec.time, todFromMin, todToMin);
              modelSeries[mdl] = applyMaskToRecord(rec, mask);
            } else {
              modelSeries[mdl] = rec;
            }
            modelStatus[mdl] = 'ok';
          } catch(e){
            console.error('Model fetch failed', mdl, e);
            inc();
            modelStatus[mdl] = 'err';
          }
        }

        /* ----- ERA5 loop ----- */
        if (era5On){
          try {
            if (!eraStart || !eraEnd) throw new Error('Select start and end dates for ERA5.');

            const yearList = eraYearsSelected.length ? eraYearsSelected : [];
            const reqRanges = [];

            if (yearList.length){
              const sY = parseInt(eraStart.slice(0,4),10);
              const eY = parseInt(eraEnd.slice(0,4),10);
              for (const Y of yearList){
                if (Y < sY || Y > eY) continue;
                const months = eraMonthsMap.get(Y) || [];
                const monthsToUse = months.length ? months : [];
                for (const M of monthsToUse){
                  const mStart = `${Y}-${String(M).padStart(2,'0')}-01`;
                  const mEnd   = `${Y}-${String(M).padStart(2,'0')}-${String(lastDayOfMonth(Y,M)).padStart(2,'0')}`;
                  const rngStart = (mStart < eraStart) ? eraStart : mStart;
                  const rngEnd   = (mEnd   > eraEnd)   ? eraEnd   : mEnd;
                  if (rngEnd >= rngStart) reqRanges.push([rngStart, rngEnd]);
                }
              }
              if (!reqRanges.length) reqRanges.push([eraStart, eraEnd]);
            } else {
              reqRanges.push([eraStart, eraEnd]);
            }

            const acc = {
              time: [],
              wind_speed_10m: [],
              wind_direction_10m: [],
              temperature_2m: [],
              precipitation: [],
              wind_gusts_10m: [],
              pressure_msl: [],
              cloud_cover: [],
              boundary_layer_height: [],
              pl: {}
            };
            for (const p of levels){ acc.pl[p] = { ws:[], wd:[], tt:[] }; }

            for (const [rngStart, rngEnd] of reqRanges){
              const era = new URL('https://archive-api.open-meteo.com/v1/era5');
              era.searchParams.set('latitude',  loc.lat);
              era.searchParams.set('longitude', loc.lon);
              era.searchParams.set('start_date', rngStart);
              era.searchParams.set('end_date',   rngEnd);
              era.searchParams.set('timezone',   'auto');
              era.searchParams.set('temperature_unit', 'celsius');
              era.searchParams.set('wind_speed_unit',  'kn');
              era.searchParams.set('precipitation_unit','mm');
              era.searchParams.set('pressure_unit', 'hPa');
              era.searchParams.set('hourly', hourly.join(','));

              if (todEnabled && todFrom && todTo && rngStart === rngEnd){
                const [startISO, endISO] = contiguousIsoRangeIfSingleDay(rngStart, todFrom, todTo);
                maybeApplyHourWindow(era, startISO, endISO);
              }

              const r = await fetch(era.toString());
              const js = await r.json();
              inc();

              if (!js?.hourly?.time?.length) continue;
              const h = js.hourly;

              acc.time.push(...h.time);
              acc.wind_speed_10m.push(...(h.wind_speed_10m || []));
              acc.wind_direction_10m.push(...(h.wind_direction_10m || []));
              acc.temperature_2m.push(...(h.temperature_2m || []));
              acc.precipitation.push(...(h.precipitation || h.rain || []));
              acc.wind_gusts_10m.push(...(h.wind_gusts_10m || []));
              acc.pressure_msl.push(...(h.pressure_msl || []));
              acc.cloud_cover.push(...(h.cloud_cover || h.cloudcover || []));
              acc.boundary_layer_height.push(...(h.boundary_layer_height || h.pbl_height || []));

              for (const p of levels){
                const ws = h[`windspeed_${p}hPa`]     || h[`wind_speed_${p}hPa`]      || [];
                const wd = h[`winddirection_${p}hPa`] || h[`wind_direction_${p}hPa`]  || [];
                const tt = h[`temperature_${p}hPa`]   || [];
                acc.pl[p].ws.push(...ws);
                acc.pl[p].wd.push(...wd);
                acc.pl[p].tt.push(...tt);
              }
            }

            if (!acc.time.length){
              modelStatus['era5'] = 'no';
            } else {
              const idx = acc.time.map((t,i)=>({t,i})).sort((a,b)=>
                (a.t < b.t ? -1 : a.t > b.t ? 1 : a.i - b.i)
              );
              const reorder = (arr)=> idx.map(o => arr[o.i]);
              const eraRec = {
                time: reorder(acc.time),
                wind_speed_10m:     reorder(acc.wind_speed_10m),
                wind_direction_10m: reorder(acc.wind_direction_10m),
                temperature_2m:     reorder(acc.temperature_2m),
                precipitation:      reorder(acc.precipitation),
                wind_gusts_10m:     reorder(acc.wind_gusts_10m),
                pressure_msl:       reorder(acc.pressure_msl),
                cloud_cover:        reorder(acc.cloud_cover),
                boundary_layer_height: reorder(acc.boundary_layer_height),
                pl: {}
              };
              for (const p of levels){
                eraRec.pl[p] = {
                  ws: reorder(acc.pl[p].ws),
                  wd: reorder(acc.pl[p].wd),
                  tt: reorder(acc.pl[p].tt),
                };
              }

              if (todEnabled && todFromMin!=null && todToMin!=null){
                const mask = buildTodIndexMask(eraRec.time, todFromMin, todToMin);
                modelSeries['era5'] = applyMaskToRecord(eraRec, mask);
              } else {
                modelSeries['era5'] = eraRec;
              }
              modelStatus['era5'] = 'ok';
            }
          } catch(e){
            console.error('ERA5 fetch failed', e);
            inc();
            modelStatus['era5'] = 'err';
          }
        }

        /* ----- Marine (optional) ----- */
        if (includeMarine){
          try {
            const mu = new URL('https://marine-api.open-meteo.com/v1/marine');
            mu.searchParams.set('latitude',  loc.lat);
            mu.searchParams.set('longitude', loc.lon);
            mu.searchParams.set('hourly', 'wave_height');
            mu.searchParams.set('forecast_days', Math.min(days,7));
            const mres = await fetch(mu.toString());
            const mjs  = await mres.json();
            inc();

            const wave_time   = mjs.hourly && mjs.hourly.time ? mjs.hourly.time : null;
            const wave_height = mjs.hourly && mjs.hourly.wave_height ? mjs.hourly.wave_height : null;
            if (wave_height){
              Object.values(modelSeries).forEach(rec => {
                rec.wave_time   = wave_time || rec.time;
                rec.wave_height = wave_height;
              });
            }
          } catch(e){
            console.warn('Marine failed', e);
            inc();
          }
        }

        /* ----- Status chips ----- */
        const statusModels = [...Object.keys(modelStatus)];
        const statusHtml = statusModels.map(mdl => {
          const st = modelStatus[mdl] || 'no';
          const theCls = (st === 'ok') ? 'ok' : (st === 'err' ? 'err' : 'no');
          const text   = (st === 'ok') ? '✓ loaded' : (st === 'err' ? '✕ failed' : '– no coverage');
          return `<span class="status-chip ${theCls}">${labelFor(mdl)}<span>${text}</span></span>`;
        }).join('');
        statusBar.innerHTML = statusHtml || '<span class="small muted">No model responses.</span>';

        /* ----- Charts (with ERA climatology) ----- */
        const modelsWithData = Object.keys(modelSeries);
        const eraOnly        = (modelsWithData.length === 1 && modelsWithData[0] === 'era5');
        const isEraClimatology = eraOnly && era5On && eraYearsSelected.length > 1;

        let eraClimatology = null;
        function getEraClimatology(){
          if (!eraClimatology && modelSeries['era5']){
            eraClimatology = buildEraClimatology(modelSeries['era5']);
          }
          return eraClimatology;
        }

        function makeTraces(varKey, label, opts = {}){
          const traces = [];

          // ERA daily climatology mode (only ERA5, multi-year)
          if (isEraClimatology && opts.climatology){
            const clim = getEraClimatology();
            if (!clim) return traces;

            const x = clim.day;

            if (varKey === 'wind_speed_10m'){
              traces.push({
                x, y: clim.tws_mean,
                name: 'ERA5 mean',
                mode:'lines',
                hovertemplate: 'Day %{x}<br>' + label + ' mean: %{y:.1f}<extra>ERA5</extra>'
              });
              traces.push({
                x, y: clim.tws_min,
                name: 'ERA5 min',
                mode:'lines',
                line:{ dash:'dot', width:1.5 },
                hovertemplate: 'Day %{x}<br>' + label + ' min: %{y:.1f}<extra>ERA5</extra>'
              });
              traces.push({
                x, y: clim.tws_max,
                name: 'ERA5 max',
                mode:'lines',
                line:{ dash:'dot', width:1.5 },
                hovertemplate: 'Day %{x}<br>' + label + ' max: %{y:.1f}<extra>ERA5</extra>'
              });
            } else if (varKey === 'temperature_2m'){
              traces.push({
                x, y: clim.t2m_mean,
                name: 'ERA5 mean',
                mode:'lines',
                hovertemplate: 'Day %{x}<br>' + label + ' mean: %{y:.1f}<extra>ERA5</extra>'
              });
              traces.push({
                x, y: clim.t2m_min,
                name: 'ERA5 min',
                mode:'lines',
                line:{ dash:'dot', width:1.5 },
                hovertemplate: 'Day %{x}<br>' + label + ' min: %{y:.1f}<extra>ERA5</extra>'
              });
              traces.push({
                x, y: clim.t2m_max,
                name: 'ERA5 max',
                mode:'lines',
                line:{ dash:'dot', width:1.5 },
                hovertemplate: 'Day %{x}<br>' + label + ' max: %{y:.1f}<extra>ERA5</extra>'
              });
            } else if (varKey === 'pressure_msl'){
              traces.push({
                x, y: clim.pmsl_mean,
                name: 'ERA5 mean',
                mode:'lines',
                hovertemplate: 'Day %{x}<br>' + label + ' mean: %{y:.1f}<extra>ERA5</extra>'
              });
              traces.push({
                x, y: clim.pmsl_min,
                name: 'ERA5 min',
                mode:'lines',
                line:{ dash:'dot', width:1.5 },
                hovertemplate: 'Day %{x}<br>' + label + ' min: %{y:.1f}<extra>ERA5</extra>'
              });
              traces.push({
                x, y: clim.pmsl_max,
                name: 'ERA5 max',
                mode:'lines',
                line:{ dash:'dot', width:1.5 },
                hovertemplate: 'Day %{x}<br>' + label + ' max: %{y:.1f}<extra>ERA5</extra>'
              });
            } else if (varKey === 'wind_direction_10m'){
              traces.push({
                x, y: clim.twd_mean,
                name: 'ERA5 mean',
                mode:'lines',
                hovertemplate: 'Day %{x}<br>' + label + ': %{y:.0f}°<extra>ERA5</extra>'
              });
            } else if (varKey === 'precipitation'){
              traces.push({
                x, y: clim.rain_mean,
                name: 'ERA5 mean',
                mode:'lines',
                hovertemplate: 'Day %{x}<br>' + label + ' mean: %{y:.2f}<extra>ERA5</extra>'
              });
            }
            return traces;
          }

          // Default: forecast-style traces over full time axis
          modelsWithData.forEach(mdl => {
            const rec = modelSeries[mdl];
            const arr = rec && rec[varKey];
            if (!arr || !arr.length) return;
            traces.push({
              x: rec.time,
              y: arr,
              name: nameOf(mdl),
              mode: 'lines',
              line: { width: 2 },
              hovertemplate: `%{x}<br>${label}: %{y}<extra>${nameOf(mdl)}</extra>`
            });
          });
          return traces;
        }

        const twsLayout  = isEraClimatology ? layoutClim('True Wind Speed (10 m, kn)', 'Day of month')
                                            : layout('True Wind Speed (10 m, kn)');
        const twdLayout  = isEraClimatology ? layoutClim('True Wind Direction (°)', 'Day of month')
                                            : layout('True Wind Direction (°)');
        const rainLayout = isEraClimatology ? layoutClim('Precipitation (mm/hr)', 'Day of month')
                                            : layout('Precipitation (mm/hr)');
        const t2mLayout  = isEraClimatology ? layoutClim('Air Temperature (°C)', 'Day of month')
                                            : layout('Air Temperature (°C)');
        const pmslLayout = isEraClimatology ? layoutPmslClim('Sea-level Pressure (hPa)')
                                            : layoutPmsl('Sea-level Pressure (hPa)');

        renderPlotOrMsg(
          `chart_${loc.id}_TWS`,
          makeTraces('wind_speed_10m','TWS (kn)', {climatology:true}),
          twsLayout
        );

        renderPlotOrMsg(
          `chart_${loc.id}_TWD`,
          makeTraces('wind_direction_10m','TWD (°)', {climatology:true}),
          twdLayout
        );

        renderPlotOrMsg(
          `chart_${loc.id}_RAIN`,
          makeTraces('precipitation','Precip (mm/hr)', {climatology:true}),
          rainLayout
        );

        renderPlotOrMsg(
          `chart_${loc.id}_T2M`,
          makeTraces('temperature_2m','T2m (°C)', {climatology:true}),
          t2mLayout
        );

        const waveTraces = [];
        const marineRec  = Object.values(modelSeries).find(r => r && r.wave_height);
        if (marineRec){
          waveTraces.push({
            x: marineRec.wave_time || marineRec.time,
            y: marineRec.wave_height,
            name:'Marine (SWH)',
            mode:'lines',
            line:{width:2}
          });
        }

        renderPlotOrMsg(
          `chart_${loc.id}_SWH`,
          waveTraces,
          layout('Significant Wave Height (m)')
        );

        renderPlotOrMsg(
          `chart_${loc.id}_PMSL`,
          makeTraces('pressure_msl','MSLP (hPa)', {climatology:true}),
          pmslLayout
        );

        /* ----- Wind rose render ----- */
        const modelOptionsNow = Object.keys(modelSeries);
        const sel = document.getElementById(roseSelectId);
        if (sel){
          const selectHtml = [`<option value="__all__">All models combined</option>`]
            .concat(modelOptionsNow.map(m => `<option value="${m}">${nameOf(m)}</option>`))
            .join('');
          sel.innerHTML = selectHtml;

          function renderRose(choice){
            let samples;
            if (choice === '__all__'){
              const list = Object.keys(modelSeries).map(k => buildWindSamplesFromSeries(modelSeries[k]));
              samples = concatSamples(list);
            } else {
              samples = buildWindSamplesFromSeries(modelSeries[choice]);
            }
            const { s, d } = samples;

            const stats = computeWindStats(s, d);
            const tbl = document.getElementById(roseTblId);
            if (tbl){
              tbl.innerHTML = `
                <tr><td>Mean TWS</td><td style="text-align:right;">${formatKn(stats.meanTws)}</td></tr>
                <tr><td>Peak frequency</td><td style="text-align:right;">${formatPct(stats.peakPct)}</td></tr>
                <tr><td>% Calm (&lt;4 kt)</td><td style="text-align:right;">${formatPct(stats.calmPct)}</td></tr>
                <tr><td>% &ge;25 kt</td><td style="text-align:right;">${formatPct(stats.highPct25)}</td></tr>
                <tr><td>Peak TWD (dir bin)</td><td style="text-align:right;">${formatDeg(stats.peakDir)}</td></tr>
              `;
            }

            const { counts, dirTotals, speedBins, dirLabels } = binWindsCustom(s, d);
            const total = s.length || 1;

            for (let di = 0; di < 36; di++){
              for (let sb = 0; sb < speedBins.length; sb++){
                counts[di][sb] = 100 * counts[di][sb] / total;
              }
              dirTotals[di] = 100 * dirTotals[di] / total;
            }

            const traces = makeWindRoseTraces(counts, speedBins, dirLabels);
            const roseLayout = {
              ...BASE_PLOTLY_LAYOUT,
              title: { ...BASE_PLOTLY_LAYOUT.title, text: 'Wind Rose (% of samples)' },
              margin: { l: 40, r: 40, t: 54, b: 40 },
              polar: {
                bgcolor: '#0f1420',
                angularaxis: {
                  direction: "clockwise",
                  rotation: 90,
                  tickmode: 'array',
                  tickvals: [0,90,180,270],
                  ticktext: ['N','E','S','W']
                },
                radialaxis: {
                  ticksuffix: '%',
                  showline: false,
                  gridcolor: '#1f2636'
                }
              },
              barmode: 'stack',
              showlegend: true,
              legend: { orientation: 'h', x: 0, y: -0.15 }
            };

            const el = document.getElementById(rosePlotId);
            if (!s.length){
              el.innerHTML = "<div class='small muted'>No wind data in the current filters to build a wind rose.</div>";
              return;
            }
            Plotly.newPlot(rosePlotId, traces, roseLayout, PLOTLY_CONFIG);
          }

          sel.addEventListener('change', () => renderRose(sel.value));
          const defaultChoice = (Object.keys(modelSeries).length > 1) ? '__all__' : Object.keys(modelSeries)[0];
          sel.value = defaultChoice || '__all__';
          renderRose(sel.value);
        }

        /* ----- Tables (below profiles & rose) ----- */
        const modelsWithDataTbl = Object.keys(modelSeries);
        const timesSorted = buildTimesUnion(modelSeries, modelsWithDataTbl);

        const tablesWrap = document.createElement('div');
        tablesWrap.className = 'grid';
        tablesWrap.style.marginTop = '10px';

        const twsCard = document.createElement('div');
        twsCard.className = 'card';
        twsCard.innerHTML = `
          <div class='section-title'>TWS (kn) — by Time × Model</div>
          <div class="legend"><span class="badge">TWS bins: ${TWS_BIN_LABELS.join(', ')}</span></div>
          <div id="tbl_tws_${loc.id}" style="margin-top:4px;"></div>`;
        tablesWrap.appendChild(twsCard);

        const twdCard = document.createElement('div');
        twdCard.className = 'card';
        twdCard.innerHTML = `
          <div class='section-title'>TWD (°) — by Time × Model</div>
          <div class="legend"><span class="badge">Colour vs model's mean: left (−) = red, right (+) = green</span></div>
          <div id="tbl_twd_${loc.id}" style="margin-top:4px;"></div>`;
        tablesWrap.appendChild(twdCard);

        const t2mCard = document.createElement('div');
        t2mCard.className = 'card';
        t2mCard.innerHTML = `
          <div class='section-title'>Air Temperature (°C) — by Time × Model</div>
          <div class="legend"><span class="badge">Using same colour scale as TWS bins</span></div>
          <div id="tbl_t2m_${loc.id}" style="margin-top:4px;"></div>`;
        tablesWrap.appendChild(t2mCard);

        locContainer.appendChild(tablesWrap);

        const idxMap = {};
        modelsWithDataTbl.forEach(mdl => {
          const tArr = modelSeries[mdl].time || [];
          const idx = new Map();
          tArr.forEach((t,i)=>idx.set(t,i));
          idxMap[mdl] = idx;
        });

        const meanDir = {};
        modelsWithDataTbl.forEach(mdl => {
          const arr = modelSeries[mdl].wind_direction_10m || [];
          meanDir[mdl] = circMeanDeg(arr);
        });

        function twsGetter(ts, mdl){
          const rec = modelSeries[mdl];
          const i = idxMap[mdl].get(ts);
          if (i==null) return '';
          const v = rec.wind_speed_10m[i];
          return (v==null)? '' : v;
        }

        function twsColor(v){
          const k = twsBinIndex(Number(v));
          return TWS_COLOURS[k] || '#444';
        }

        function t2mGetter(ts, mdl){
          const rec = modelSeries[mdl];
          const i = idxMap[mdl].get(ts);
          if (i==null) return '';
          const v = rec.temperature_2m[i];
          return (v==null)? '' : v;
        }

        function t2mColor(v){ return colorForTempC(Number(v)); }

        function twdGetter(ts, mdl){
          const rec = modelSeries[mdl];
          const i = idxMap[mdl].get(ts);
          if (i==null) return '';
          const v = rec.wind_direction_10m[i];
          return (v==null)? '' : v;
        }

        function twdColor(v, ts, mdl){
          const mean = meanDir[mdl];
          if (v==='' || mean==null) return null;
          const d = angDiff(Number(v), mean);
          const mag = Math.min(Math.abs(d)/90, 1);
          const alpha = 0.25 + 0.45*mag;
          return d >= 0
            ? `rgba(40, 167, 69, ${alpha})`
            : `rgba(220, 53, 69, ${alpha})`;
        }

        function degFmt(v){
          return (v==='' ? '' : Math.round(Number(v)) + '°');
        }

        renderVarMatrixTable(
          document.getElementById(`tbl_tws_${loc.id}`),
          timesSorted,
          modelsWithDataTbl,
          modelSeries,
          twsGetter,
          twsColor,
          v => v==='' ? '' : Number(v).toFixed(1)
        );

        renderVarMatrixTable(
          document.getElementById(`tbl_twd_${loc.id}`),
          timesSorted,
          modelsWithDataTbl,
          modelSeries,
          twdGetter,
          twdColor,
          degFmt
        );

        renderVarMatrixTable(
          document.getElementById(`tbl_t2m_${loc.id}`),
          timesSorted,
          modelsWithDataTbl,
          modelSeries,
          t2mGetter,
          t2mColor,
          v => v==='' ? '' : Number(v).toFixed(1)
        );

        /* ----- Vertical profile + BLH ----- */
        function drawProfile(){
          const ti = parseInt(document.getElementById(`prof_idx_${loc.id}`).value || '0');
          const modelsWithDataProf = Object.keys(modelSeries).filter(m => modelSeries[m]?.time?.length);

          const leftTraces = [];
          modelsWithDataProf.forEach(mdl => {
            const rec = modelSeries[mdl];
            const yP = [], ws = [], tt = [];
            Object.keys(rec.pl).forEach(p => {
              const arr = rec.pl[p];
              if (!arr) return;
              const vws = (arr.ws || [])[ti];
              const vtt = (arr.tt || [])[ti];
              if (vws==null && vtt==null) return;
              yP.push(parseInt(p));
              ws.push(vws ?? null);
              tt.push(vtt ?? null);
            });
            if (yP.length){
              leftTraces.push({
                x: ws, y: yP,
                name: mdl + ' TWS',
                mode:'lines+markers',
                xaxis:'x',
                yaxis:'y',
                marker:{size:4},
                line:{width:1.5},
                hovertemplate:'%{y} hPa<br>TWS %{x:.1f} kn<extra>'+mdl+'</extra>'
              });
              leftTraces.push({
                x: tt, y: yP,
                name: mdl + ' Temp',
                mode:'lines+markers',
                xaxis:'x2',
                yaxis:'y',
                marker:{size:4},
                line:{width:1.5},
                hovertemplate:'%{y} hPa<br>T %{x:.1f} °C<extra>'+mdl+'</extra>'
              });
            }
          });

          const leftLayout = {
            ...BASE_PLOTLY_LAYOUT,
            height: 300,
            title: { ...BASE_PLOTLY_LAYOUT.title, text: 'TWS (bottom) & Temp (top) vs Pressure' },
            margin: { l: 56, r: 24, t: 54, b: 76 },
            yaxis:  { ...BASE_PLOTLY_LAYOUT.yaxis, title:'Pressure (hPa)', autorange:'reversed' },
            xaxis:  {
              type:'linear',
              title:'TWS (kn)',
              automargin:true,
              gridcolor:'#1f2636',
              linecolor:'#2a3347',
              ticks:'outside',
              tickcolor:'#2a3347'
            },
            xaxis2: {
              type:'linear',
              overlaying:'x',
              side:'top',
              title:'Temp (°C)',
              zeroline:false,
              showgrid:false
            }
          };

          renderPlotOrMsg(`profile_left_${loc.id}`, leftTraces, leftLayout);

          // BLH from GFS only
          const gfs = modelSeries['gfs_seamless'];
          const valEl = document.getElementById(`blh_value_${loc.id}`);
          const metaEl = document.getElementById(`blh_meta_${loc.id}`);

          if (!gfs) {
            if (valEl) valEl.textContent = '—';
            if (metaEl) metaEl.textContent = 'GFS not loaded.';
            return;
          }

          const blhArr = gfs.boundary_layer_height || [];
          const tArr   = gfs.time || [];
          const blhVal = blhArr[ti];
          const tIso   = tArr[ti];

          if (valEl) valEl.textContent = (blhVal==null || isNaN(blhVal)) ? '—' : `${Math.round(blhVal)} m`;
          if (metaEl) metaEl.textContent = tIso ? `at ${tIso}` : '';
        }

        drawProfile();
        document.getElementById(`prof_idx_${loc.id}`).addEventListener('change', drawProfile);

        createdPanes.push(loc.id);

      } catch(err){
        console.error(`Location #${loc.id} rendering failed`, err);
      }
    }

    if (createdPanes.length) activateTab(createdPanes[0]);
    document.getElementById('progressText').textContent += ' — Done';
  }

  /* ---------- (placeholder) export matrix helper ---------- */
  function aoaFromMatrix(timesSorted, models, getter, formatter){
    const header = ['Time', ...models.map(nameOf)];
    const aoa = [header];
    timesSorted.forEach(ts=>{
      const row = [ts];
      models.forEach(m=>{
        const v = getter(ts, m);
        row.push(formatter ? formatter(v) : (v===''?'':Number(v).toFixed(1)));
      });
      aoa.push(row);
    });
    return aoa;
  }

}); // DOMContentLoaded for Leaflet & app
</script>
</body>
</html>
