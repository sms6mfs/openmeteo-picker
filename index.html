<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Multi-Model Weather Picker • Open-Meteo</title>
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <!-- SheetJS for XLSX export -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root { color-scheme: dark; }
    body {margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif; background:#0e1116; color:#e6e6e6; --header-h:64px; padding-top:var(--header-h);}
    header{ display:flex; gap:12px; align-items:center; padding:12px 16px; border-bottom:1px solid #222; position:fixed; top:0; left:0; right:0; background:#0e1116; z-index:1000; }
    header h1 { font-size:18px; margin:0; font-weight:600; letter-spacing:0.2px; }
    .container { display:grid; grid-template-columns:360px 1fr; gap:12px; padding:12px; }
    #map { height:460px; border-radius:12px; overflow:hidden; border:1px solid #222; }
    .panel { background:#121722; border:1px solid #202636; border-radius:12px; padding:12px; box-shadow:0 0 0 1px #000 inset; }
    .panel h2 { font-size:14px; font-weight:700; letter-spacing:0.3px; margin:0 0 8px 0; color:#bcdcff; }
    .small { font-size:12px; color:#b0b8c7; }
    .row { display:flex; gap:8px; flex-wrap:wrap; }
    label { font-size:12px; color:#cfd6e6; }
    select, input[type="number"], input[type="date"], input[type="time"], button { background:#0f1420; color:#e6e6e6; border:1px solid #283041; border-radius:8px; padding:8px 10px; font:inherit; }
    button.primary { background:#2b5cff; border-color:#2b5cff; color:white; font-weight:600; }
    button.ghost { background:#11151f; border-color:#2a3347; color:#cfd6e6; }
    .chips { display:flex; flex-wrap:wrap; gap:6px; margin:8px 0; }
    .chip { background:#1a2030; border:1px solid #2a3347; border-radius:999px; padding:4px 8px; font-size:12px; }
    .loc-list { max-height:180px; overflow:auto; border:1px dashed #2a3347; padding:6px; border-radius:8px; }
    .loc-item { display:flex; justify-content:space-between; align-items:center; padding:4px 6px; border-bottom:1px dashed #222c40; font-size:12px; }
    .loc-item:last-child { border-bottom:none; }
    .grid { display:grid; grid-template-columns: repeat(2, minmax(260px,1fr)); gap:12px; }
    .grid-3 { display:grid; grid-template-columns: repeat(3, minmax(260px,1fr)); gap:12px; }
    details { border:1px solid #1f2636; border-radius:8px; padding:6px 8px; }
    details summary { cursor:pointer; color:#c8d7ff; font-weight:600; }
    table { width:100%; border-collapse:collapse; font-size:12px; }
    th, td { border-bottom:1px solid #1d2536; padding:6px 8px; text-align:right; }
    th:first-child, td:first-child { text-align:left; }
    .section-title { margin:18px 0 8px 0; font-weight:700; color:#bcdcff; font-size:14px; }
    .card { background:#121722; border:1px solid #202636; border-radius:12px; padding:8px; }
    .muted { color:#8fa3c0; }
    .badge { font-size:11px; padding:2px 6px; border:1px solid #2a3347; border-radius:6px; background:#192235; }
    .footer { padding:12px; font-size:12px; color:#8aa; text-align:center; border-top:1px solid #222; }
    .status-chip { display:inline-flex; align-items:center; gap:6px; font-size:11px; padding:2px 6px; border-radius:999px; border:1px solid #2a3347; background:#192235; margin:3px 4px 0 0; }
    .ok { border-color:#1e8f5a; background:#10261c; color:#9be5b7; }
    .no { border-color:#8f6b1e; background:#261d10; color:#e5d09b; }
    .err { border-color:#8f1e1e; background:#261010; color:#e59b9b; }
    .profile-row { display:flex; gap:8px; align-items:stretch; }
    .profile-left  { flex:0 0 56%; min-width:260px; height:320px; }
    .profile-right { flex:0 0 34%; min-width:220px; height:320px; display:flex; flex-direction:column; justify-content:center; align-items:flex-start; padding:12px; border:1px solid #202636; border-radius:12px; background:#121722; }
    .tabs { background:#121722; border:1px solid #202636; border-radius:12px; }
    .tab-bar { display:flex; gap:6px; padding:8px; border-bottom:1px solid #202636; flex-wrap:wrap; }
    .tab-btn { background:#151b28; border:1px solid #2a3347; color:#cfd6e6; padding:6px 10px; border-radius:8px; cursor:pointer; font-size:12px; }
    .tab-btn.active { background:#2b5cff; border-color:#2b5cff; color:#fff; }
    .tab-content { padding:12px; }
    .tab-pane { display:none; }
    .tab-pane.active { display:block; }
    @media (max-width:1100px){ .container { grid-template-columns:1fr; } #map { height:320px; } }
    @media (max-width:900px){ .profile-row { flex-direction:column; } .profile-left,.profile-right{ flex:0 0 auto; width:100%; } }
    .table-wrap {max-height: 52vh; overflow: auto; border: 1px solid #2a2f3a; border-radius: 10px;}
	.table {width: 100%; border-collapse: collapse; table-layout: fixed;font-size: clamp(12px, 0.95vw, 14px); line-height: 1.25; }
	.table th, .table td {padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.06); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
	.table thead th { position: sticky; top: 0; z-index: 1; text-align: left; background: linear-gradient(0deg, rgba(0,0,0,0.0), rgba(0,0,0,0.0)) , #151922; backdrop-filter: saturate(120%) blur(2px); }
	.table .num { text-align: right; }
	.table.table--compact th, 
	.table.table--compact td { padding: 4px 6px; }
	@media (max-width: 900px) {
	  .table-wrap { max-height: 44vh; }
	  .grid { grid-template-columns: 1fr; } }
    .heat { width:100%; border-collapse:collapse; font-size:12px; }
    .heat th, .heat td { border-bottom:1px solid #1d2536; padding:6px 8px; text-align:right; }
    .heat th:first-child, .heat td:first-child { text-align:left; position:sticky; left:0; background:#121722; }
    .cell { color:#fff; border-radius:4px; padding:2px 6px; display:inline-block; min-width:48px; text-align:center; }
    .legend { display:flex; gap:8px; flex-wrap:wrap; margin:6px 0 0 0; font-size:11px; }
    .era-year-row{ border:1px dashed #2a3347; border-radius:8px; padding:8px; margin:8px 0; }
    .era-year-head{ display:flex; align-items:center; gap:8px; margin-bottom:6px; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>
  <header>
    <h1>Multi-Model Forecast Picker — Open-Meteo</h1>
    <div class="small">Pick points on the map, choose models & variables, then compare time-series and profiles.</div>
    <div style="margin-left:auto" class="small">Units fixed: <span class="badge">°C</span> <span class="badge">kn</span> <span class="badge">mm</span> <span class="badge">hPa</span></div>
  </header>

  <div class="container">
    <!-- Controls -->
    <div class="panel">
      <h2>1) Pick Locations</h2>
      <div id="map"></div>
      <div class="small">Click the map to add locations. Drag to move. Click a marker to remove.</div>
      <div class="loc-list" id="locList"></div>

      <h2 style="margin-top:10px">2) Models & Period</h2>
      <div class="row">
        <label>Forecast days (1–10): <input type="number" id="days" min="1" max="10" value="1" style="width:80px"></label>
      </div>
      <details open>
        <summary>Choose weather models</summary>
        <div class="chips" id="models"></div>
        <div class="small muted">Tip: Mix global + regional models. If a model has no coverage for a point, it will be skipped.</div>
      </details>

      <!-- HISTORICAL ERA: ERA5 -->
      <div class="section-title" style="margin-top:10px">Historical (ERA5 Reanalysis)</div>
      <div class="row small">
        <label><input type="checkbox" id="era5_toggle"> Include ERA5 historical (archive)</label>
      </div>
      <div class="row small" id="era5_dates" style="gap:12px; align-items:center;">
        <label>Start date:
          <input type="date" id="era5_start" />
        </label>
        <label>End date:
          <input type="date" id="era5_end" />
        </label>
        <span class="muted">ERA5 lags a few days; most recent dates may be unavailable.</span>
      </div>

      <!-- ERA5 YEAR PICKER -->
      <div class="row small" id="era5_years_row" style="gap:8px; align-items:center;">
        <div id="era5_years_box" class="chips"></div>
        <button class="ghost" type="button" id="era5_years_all">All</button>
        <button class="ghost" type="button" id="era5_years_none">None</button>
      </div>
      <div class="small muted">Pick exact years within the date span. If none are selected, the whole span is used.</div>

      <!-- ERA5 MONTHS PER YEAR -->
      <div id="era5_months_box"></div>
      <div class="small muted">Toggle months per selected year. By default, all months are included for each year.</div>

      <!-- TIME OF DAY FILTER -->
      <div class="section-title" style="margin-top:10px">Time-of-day filter</div>
      <div class="row small">
        <label>Keep hours between
          <input type="time" id="tod_from" value="06:00" style="width:120px">
        </label>
        <label>and
          <input type="time" id="tod_to" value="18:00" style="width:120px">
        </label>
        <label><input type="checkbox" id="tod_enable"> Apply filter</label>
      </div>
      <div class="small muted">Filter is applied client-side (always). When possible (single-day ERA queries), we also hint the server to reduce bytes.</div>

      <h2 style="margin-top:10px">3) Variables</h2>
      <div class="small">10 m wind (speed & direction) is always included. Select additional variables to download.</div>
      <div class="grid">
        <div>
          <div class="section-title">Surface</div>
          <label><input type="checkbox" class="var" value="temperature_2m" checked> Temperature (2 m)</label><br>
          <label><input type="checkbox" class="var" value="precipitation" checked> Precipitation</label><br>
          <label><input type="checkbox" class="var" value="wind_gusts_10m" checked> Wind Gusts (10 m)</label><br>
          <label><input type="checkbox" class="var" value="pressure_msl" checked> Sea-level Pressure</label><br>
          <label><input type="checkbox" class="var" value="cloud_cover" checked> Cloud Cover Total</label><br>
          <label><input type="checkbox" class="var" value="boundary_layer_height" checked> Boundary Layer Height (PBL)</label><br>
        </div>
        <div>
          <div class="section-title">Marine</div>
          <label><input type="checkbox" id="marine_swh" checked> Significant Wave Height (m)</label>
          <div class="small muted">(via Marine API; 7-day max horizon)</div>
        </div>
      </div>

      <div class="section-title">Upper-air pressure levels</div>
      <div class="small">We fetch T (°C), wind speed (kn) & wind dir (°) for these levels where available.</div>
      <div class="chips" id="plChips"></div>

      <div class="row" style="margin-top:10px">
        <button class="primary" id="runBtn">Fetch Forecasts</button>
        <button class="ghost" id="pdfBtn">Export Full Report (PDF)</button>
      </div>
      <div id="progress" class="small muted" style="margin-top:8px; display:none;">
        <div style="height:8px;background:#1f2636;border-radius:6px;overflow:hidden;">
          <div id="progressBar" style="height:8px;width:0%;background:#2b5cff;"></div>
        </div>
        <div id="progressText" style="margin-top:6px;"></div>
      </div>
    </div>

    <!-- Results: tabbed per location -->
    <div class="tabs">
      <div class="tab-bar" id="tabBar"></div>
      <div class="tab-content" id="tabContent"></div>
    </div>
  </div>

  <div class="footer">Data © Open-Meteo & respective model providers. Free for non-commercial use.</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const hdr = document.querySelector('header');
    const setPad = () => { if (!hdr) return; document.body.style.setProperty('--header-h', hdr.offsetHeight + 'px'); };
    setPad(); window.addEventListener('resize', setPad);
  });

/* ==== Model mapping ==== */
const MODEL_CODES = {
  "ECMWF IFS 0.25": "ecmwf_ifs025",
  "DWD ICON EU": "icon_eu",
  "Meteo-France ARPEGE World": "arpege_world",
  "Meteo-France ARPEGE Europe": "arpege_europe",
  "Meteo-France AROME France": "arome_france",
  "Meteo-France AROME France HD": "arome_france_hd",
  /* "UKMO UKV 2km": "ukmo_uk_deterministic_2km",*/
  "UKMO Seamless": "ukmo_seamless",
  "NCEP GFS Global Seamless": "gfs_seamless",
  "NCEP HRRR U.S. Conus": "hrrr_conus",
  "NCEP NAM U.S. Conus": "nam_conus",
  "ItaliaMeteo ARPAE ICON 2I": "arpae_icon_2i"
};

const PRESSURE_LEVELS = [975,950,925,900,850,700,600,500,400,300,250,200,150];
function buildHourlyVars(s){ return ["wind_speed_10m","wind_direction_10m"].concat(s); }
function buildPressureLevelVars(levels){
  const v = [];
  levels.forEach(p=>{
    v.push(`temperature_${p}hPa`, `windspeed_${p}hPa`, `winddirection_${p}hPa`);
  });
  return v;
}

/* ==== Helpers ==== */
function hhmmToMin(hhmm){
  if(!hhmm) return null;
  const [h,m] = hhmm.split(':').map(Number);
  return (isNaN(h)||isNaN(m)) ? null : (h*60 + m);
}
function buildTodIndexMask(timeArr, fromMin, toMin){
  if (!Array.isArray(timeArr) || fromMin==null || toMin==null) return null;
  const wrap = toMin < fromMin;
  return timeArr.map((iso) => {
    const d = new Date(iso);
    const mins = d.getHours()*60 + d.getMinutes();
    return wrap ? (mins >= fromMin || mins <= toMin) : (mins >= fromMin && mins <= toMin);
  });
}
function applyMaskToRecord(rec, mask){
  if (!rec || !Array.isArray(mask)) return rec;
  const filt = (arr)=> Array.isArray(arr) ? arr.filter((_,i)=>mask[i]) : arr;
  const out = { ...rec };
  out.time = filt(rec.time);
  ['wind_speed_10m','wind_direction_10m','temperature_2m','precipitation',
   'wind_gusts_10m','pressure_msl','cloud_cover','boundary_layer_height',
   'wave_height','wave_time'].forEach(k=>{
      if (k in rec) out[k] = filt(rec[k]);
  });
  if (rec.pl){
    out.pl = {};
    Object.keys(rec.pl).forEach(p=>{
      const obj = rec.pl[p] || {};
      out.pl[p] = { ws: filt(obj.ws), wd: filt(obj.wd), tt: filt(obj.tt) };
    });
  }
  return out;
}
function listYearsBetween(startStr, endStr){
  if (!startStr || !endStr) return [];
  const ys = parseInt(startStr.slice(0,4), 10);
  const ye = parseInt(endStr.slice(0,4), 10);
  if (isNaN(ys) || isNaN(ye) || ye < ys) return [];
  const out = []; for (let y=ys; y<=ye; y++) out.push(y); return out;
}
function monthName(m){ return ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][m-1]; }
function lastDayOfMonth(y,m){ return new Date(y, m, 0).getDate(); } // m: 1-12
function renderEraYearChips(years){
  const box = document.getElementById('era5_years_box');
  if (!box) return;
  if (!years.length){
    box.innerHTML = "<span class='small muted'>Select start & end dates to choose years…</span>";
    return;
  }
  box.innerHTML = years.map(y => `<label class="chip"><input type="checkbox" class="era5-year" value="${y}" checked> ${y}</label>`).join('');
}
function renderEraMonthsPerYear(){
  const cont = document.getElementById('era5_months_box');
  if (!cont) return;
  const years = [...document.querySelectorAll('.era5-year')].map(cb => ({ y: parseInt(cb.value,10), on: cb.checked }));
  cont.innerHTML = '';
  years.filter(o=>o.on).forEach(({y})=>{
    const row = document.createElement('div');
    row.className = 'era-year-row';
    row.innerHTML = `
      <div class="era-year-head">
        <strong>${y}</strong>
        <button type="button" class="ghost era-month-all" data-year="${y}">All</button>
        <button type="button" class="ghost era-month-none" data-year="${y}">None</button>
      </div>
      <div class="chips" id="era-months-${y}">
        ${Array.from({length:12},(_,i)=>{
            const m=i+1; return `<label class="chip"><input type="checkbox" class="era5-month" data-year="${y}" value="${m}" checked> ${monthName(m)}</label>`;
        }).join('')}
      </div>`;
    cont.appendChild(row);
  });
  // Wire All/None
  cont.querySelectorAll('.era-month-all').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const y = btn.dataset.year;
      cont.querySelectorAll(`.era5-month[data-year="${y}"]`).forEach(cb=>cb.checked = true);
    });
  });
  cont.querySelectorAll('.era-month-none').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const y = btn.dataset.year;
      cont.querySelectorAll(`.era5-month[data-year="${y}"]`).forEach(cb=>cb.checked = false);
    });
  });
}
function readSelectedEraYears(){
  return [...document.querySelectorAll('.era5-year:checked')].map(el => parseInt(el.value,10)).filter(v=>!isNaN(v));
}
function readSelectedEraMonthsMap(){
  const map = new Map();
  const years = readSelectedEraYears();
  years.forEach(y=>{
    const chips = [...document.querySelectorAll(`.era5-month[data-year="${y}"]`)];
    if (!chips.length){
      map.set(y, Array.from({length:12},(_,i)=>i+1));
    } else {
      const ms = chips.filter(cb=>cb.checked).map(cb=>parseInt(cb.value,10)).filter(v=>!isNaN(v));
      map.set(y, ms.length ? ms : []);
    }
  });
  return map;
}
function setupEraYearChipWiring(){
  const s = document.getElementById('era5_start');
  const e = document.getElementById('era5_end');
  const btnAll  = document.getElementById('era5_years_all');
  const btnNone = document.getElementById('era5_years_none');
  function refreshYears(){
    renderEraYearChips(listYearsBetween(s.value, e.value));
    renderEraMonthsPerYear();
    document.querySelectorAll('.era5-year').forEach(cb=>{
      cb.addEventListener('change', renderEraMonthsPerYear);
    });
  }
  if (s) s.addEventListener('change', refreshYears);
  if (e) e.addEventListener('change', refreshYears);
  if (btnAll) btnAll.addEventListener('click', ()=>{
    document.querySelectorAll('.era5-year').forEach(cb=>cb.checked = true);
    renderEraMonthsPerYear();
  });
  if (btnNone) btnNone.addEventListener('click', ()=>{
    document.querySelectorAll('.era5-year').forEach(cb=>cb.checked = false);
    renderEraMonthsPerYear();
  });
  refreshYears();
}
document.addEventListener('DOMContentLoaded', setupEraYearChipWiring);

function contiguousIsoRangeIfSingleDay(dateStr, fromHHMM, toHHMM){
  if (!dateStr || !fromHHMM || !toHHMM) return [null, null];
  return [`${dateStr}T${fromHHMM}`, `${dateStr}T${toHHMM}`];
}
function maybeApplyHourWindow(u, startISO, endISO){
  if (!startISO || !endISO) return;
  u.searchParams.set('start_hour', startISO);
  u.searchParams.set('end_hour', endISO);
}

/* ==== Map ==== */
const map = L.map('map', { zoomControl: true }).setView([54.5, -2.5], 6);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' }).addTo(map);
let markers = []; let idSeq = 1;
map.on('click', (e) => {
  const m = L.marker(e.latlng, { draggable:true }).addTo(map);
  const loc = { marker: m, lat: e.latlng.lat, lon: e.latlng.lng, id: idSeq++ };
  markers.push(loc);
  m.on('dragend', () => { loc.lat = m.getLatLng().lat; loc.lon = m.getLatLng().lng; renderLocList(); });
  m.on('click',   () => { m.remove(); markers = markers.filter(x => x !== loc); renderLocList(); });
  renderLocList();
});
function renderLocList(){
  const box = document.getElementById('locList');
  if (!markers.length) { box.innerHTML = '<div class="small muted">No locations yet. Click the map to add markers. Click a marker to remove.</div>'; return; }
  box.innerHTML = markers.map(m => `<div class='loc-item'><span>Lat ${m.lat.toFixed(3)}, Lon ${m.lon.toFixed(3)}</span><span class='muted'>#${m.id}</span></div>`).join('');
}
renderLocList();

/* ==== Controls ==== */
const modelsDiv = document.getElementById('models');
Object.keys(MODEL_CODES).forEach(name => {
  const id = `mdl_${MODEL_CODES[name]}`;
  const el = document.createElement('label');
  el.innerHTML = `<input type='checkbox' class='model' id='${id}' value='${MODEL_CODES[name]}'> ${name}`;
  modelsDiv.appendChild(el);
});
const plDiv = document.getElementById('plChips');
PRESSURE_LEVELS.forEach(p => {
  const span = document.createElement('label'); span.className = 'chip';
  span.innerHTML = `<input type='checkbox' class='pl' value='${p}' checked> ${p} hPa`;
  plDiv.appendChild(span);
});

/* ==== Tabs ==== */
const tabBar = document.getElementById('tabBar');
const tabContent = document.getElementById('tabContent');
const paneCharts = {};
function addTab(loc){
  const tabId = `tab-${loc.id}`, paneId = `pane-${loc.id}`;
  const btn = document.createElement('button');
  btn.className = 'tab-btn'; btn.id = tabId;
  btn.innerText = `#${loc.id}  ${loc.lat.toFixed(2)}, ${loc.lon.toFixed(2)}`;
  btn.addEventListener('click', ()=>activateTab(loc.id));
  tabBar.appendChild(btn);
  const pane = document.createElement('div');
  pane.className = 'tab-pane'; pane.id = paneId;
  tabContent.appendChild(pane);
  return pane;
}
function activateTab(locId){
  [...tabBar.children].forEach(b => b.classList.toggle('active', b.id === `tab-${locId}`));
  [...tabContent.children].forEach(p => p.classList.toggle('active', p.id === `pane-${locId}`));
  (paneCharts[locId] || []).forEach(divId => { const el = document.getElementById(divId); if (el) Plotly.Plots.resize(el); });
}

function autosizeTable(tableEl) {
  if (!tableEl || !tableEl.tHead || !tableEl.tHead.rows.length) return;
  const cols = tableEl.tHead.rows[0].cells.length;
  // Ensure a <colgroup> exists
  let cg = tableEl.querySelector('colgroup');
  if (!cg) {
    cg = document.createElement('colgroup');
    tableEl.insertBefore(cg, tableEl.firstChild);
  }
  // Rebuild colgroup to match header count
  cg.innerHTML = '';
  const pct = (100 / cols);
  for (let i = 0; i < cols; i++) {
    const col = document.createElement('col');
    col.style.width = pct + '%';
    cg.appendChild(col);
  }
}

// Debounced resize observer for all .table
const _debounce = (fn, d=120) => {
  let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), d); };
};

const resizeTables = _debounce(() => {
  document.querySelectorAll('table.table').forEach(autosizeTable);
}, 120);

window.addEventListener('resize', resizeTables);

// Example: call after you render/populate each table
// const tbl = document.getElementById('forecastTable');
// autosizeTable(tbl);


/* ==== Plotly base ==== */
const BASE_PLOTLY_LAYOUT = {
  template: 'plotly_dark',
  paper_bgcolor: '#121722',
  plot_bgcolor: '#0f1420',
  hovermode: 'x unified',
  dragmode: false,
  margin: { l: 56, r: 24, t: 54, b: 60 },
  font: { family: 'Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif', size: 12, color: '#dfe7f5' },
  xaxis: { type: 'date', automargin: true, gridcolor: '#1f2636', linecolor:'#2a3347', ticks:'outside', tickcolor:'#2a3347', showspikes:true, spikemode:'across', spikesnap:'cursor', spikethickness:1 },
  yaxis: { automargin: true, gridcolor: '#1f2636', linecolor:'#2a3347', ticks:'outside', tickcolor:'#2a3347', rangemode:'tozero' },
  legend: { orientation:'h', x:0, y:-0.2, xanchor:'left', yanchor:'top', bgcolor:'rgba(0,0,0,0)' },
  title: { x:0, xanchor:'left', font:{ size:14, color:'#cfe0ff' } }
};
const PLOTLY_CONFIG = { responsive:true, displaylogo:false };
function layout(title){ return { ...BASE_PLOTLY_LAYOUT, title:{ ...BASE_PLOTLY_LAYOUT.title, text:title } }; }
function layoutPmsl(title){ const l=layout(title); l.yaxis={...l.yaxis, rangemode:'normal', range:[800,1100]}; return l; }
function renderPlotOrMsg(divId, traces, lay){
  const el=document.getElementById(divId);
  if (!traces || !traces.length){ el.innerHTML="<div class='small muted'>No data returned for the selected models/area/variables.</div>"; return; }
  traces.forEach(t => { t.line = t.line || {}; if (t.line.width == null) t.line.width = 2; t.cliponaxis = true; });
  Plotly.newPlot(divId, traces, lay, PLOTLY_CONFIG);
}

// Classic barb (kept for potential future use)
function drawClassicBarb(x0,y0,speedKn,dirDeg,color,out){
  const toRad=d=>d*Math.PI/180, rot=(x,y,a)=>[x*Math.cos(a)-y*Math.sin(a),x*Math.sin(a)+y*Math.cos(a)];
  const norm=(x,y)=>{const m=Math.hypot(x,y)||1e-6;return[x/m,y/m];};
  if (speedKn==null||dirDeg==null) return;
  if (speedKn<2){ out.push({type:'circle',xref:'x',yref:'y',x0:x0-0.07,x1:x0+0.07,y0:y0-7,y1:y0+7,line:{color,width:2}}); return; }
  const theta=toRad(dirDeg); const [ux,uy]=norm(-Math.sin(theta),-Math.cos(theta));
  const SHAFT_X=0.6,SHAFT_Y=10; const x1=x0+SHAFT_X*ux,y1=y0+SHAFT_Y*uy;
  out.push({type:'line',xref:'x',yref:'y',x0:x0,y0:y0,x1:x1,y1:y1,line:{color,width:2}});
  let s=Math.round(speedKn/5)*5; const n50=Math.floor(s/50); s-=50*n50; const n10=Math.floor(s/10); s-=10*n10; const n5=Math.floor(s/5);
  const [fx,fy]=rot(ux,uy,toRad(72)); const STEP=0.12,LONG=0.25,SHORT=0.15,PENNANT=0.30,PBASE=STEP*1.05;
  let t=0; const bp=d=>[x1-d*ux,y1-d*uy];
  for(let i=0;i<n50;i++){ const[bx,by]=bp(t); const path=`M ${bx},${by} L ${bx-PBASE*ux},${by-PBASE*uy} L ${bx+PENNANT*fx},${by+PENNANT*fy} Z`;
    out.push({type:'path',path,xref:'x',yref:'y',fillcolor:color,line:{color,width:1}}); t+=STEP*1.35; }
  for(let i=0;i<n10;i++){ const[bx,by]=bp(t); out.push({type:'line',xref:'x',yref:'y',x0:bx,y0:by,x1:bx+LONG*fx,y1:by+LONG*fy,line:{color,width:2}}); t+=STEP; }
  for(let i=0;i<n5;i++){  const[bx,by]=bp(t); out.push({type:'line',xref:'x',yref:'y',x0:bx,y0:by,x1:bx+SHORT*fx,y1:by+SHORT*fy,line:{color,width:2}}); t+=STEP; }
}

/* ==== Colors & stats ==== */
function colorForKnots(kn){
  if (kn === '' || kn == null || isNaN(kn)) return '#444';
  if (kn < 5)  return '#3d6cff';
  if (kn < 10) return '#1fa35b';
  if (kn < 15) return '#d2b100';
  if (kn < 20) return '#ff7a00';
  if (kn < 25) return '#e13b2d';
  if (kn < 30) return '#7a1830';
  return '#7d3cff';
}
function colorForTempC(tc){ return colorForKnots(tc); }
function circMeanDeg(arr){
  let sx=0, sy=0, n=0; for (const v of arr){ if (v==null||isNaN(v)) continue; const r=v*Math.PI/180; sx+=Math.cos(r); sy+=Math.sin(r); n++; }
  if (!n) return null; let ang = Math.atan2(sy,sx)*180/Math.PI; if (ang<0) ang += 360; return ang;
}
function angDiff(a,b){ return ((a - b + 540) % 360) - 180; }

// ---- Shared TWS bins & colours (tables + wind rose stay in sync)
const TWS_BINS = [0, 5, 10, 15, 20, 25, 30, Infinity];   // kt
const TWS_COLOURS = [
  '#3d6cff', // 0–5
  '#1fa35b', // 5–10
  '#d2b100', // 10–15
  '#ff7a00', // 15–20
  '#e13b2d', // 20–25
  '#7a1830', // 25–30
  '#7d3cff'  // 30+
];
const TWS_BIN_LABELS = (() => {
  const out = [];
  for (let i = 0; i < TWS_BINS.length; i++) {
    const a = TWS_BINS[i], b = TWS_BINS[i+1];
    out.push(b === Infinity ? `${a}+ kt` : `${a}–${b} kt`);
  }
  return out;
})();
function twsBinIndex(kn) {
  if (kn == null || isNaN(kn)) return 0;
  for (let i = 0; i < TWS_BINS.length; i++) {
    const a = TWS_BINS[i], b = TWS_BINS[i+1];
    if (b === Infinity) return (kn >= a) ? i : 0;
    if (kn >= a && kn < b) return i;
  }
  return 0;
}

/* ==== Heat tables ==== */
function renderVarMatrixTable(targetEl, timesSorted, modelsWithData, modelSeries, valueGetter, colorGetter, valueFormatter){
  const table=document.createElement('table'); table.className='heat';
  const thead=document.createElement('thead'); const thr=document.createElement('tr');
  thr.innerHTML = ['Time'].concat(modelsWithData.map(nameOf)).map(h=>`<th>${h}</th>`).join(''); thead.appendChild(thr); table.appendChild(thead);
  const tbody=document.createElement('tbody');
  timesSorted.forEach(ts=>{
    const tr=document.createElement('tr'); tr.innerHTML = `<td>${ts}</td>`;
    modelsWithData.forEach(mdl=>{
      const v = valueGetter(ts, mdl);
      const disp = valueFormatter ? valueFormatter(v) : (v===''? '' : Number(v).toFixed(1));
      const color = colorGetter ? colorGetter(v, ts, mdl) : null;
      const td=document.createElement('td');
      td.innerHTML = color ? `<span class="cell" style="background:${color}">${disp}</span>` : disp;
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
  targetEl.innerHTML=''; const wrap=document.createElement('div'); wrap.className='table-wrap'; wrap.appendChild(table); targetEl.appendChild(wrap);
}
function buildTimesUnion(modelSeries, modelsWithData){
  const allTimes=new Set(); modelsWithData.forEach(m => (modelSeries[m].time || []).forEach(t => allTimes.add(t)));
  return Array.from(allTimes).sort();
}

/* ==== XLSX holder (reserved) ==== */
const XLSX_SHEETS = {};

/* ==== PDF ==== */
document.addEventListener("DOMContentLoaded", () => {
  document.getElementById('pdfBtn').addEventListener('click', async () => {
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ unit: 'pt', format: 'a4' });
    const reportEl = document.body;
    const canvas = await html2canvas(reportEl, { scale: 1.5 });
    const imgData = canvas.toDataURL('image/png');
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const ratio = Math.min(pageWidth / canvas.width, pageHeight / canvas.height);
    const w = canvas.width * ratio, h = canvas.height * ratio;
    pdf.addImage(imgData, 'PNG', 0, 0, w, h);
    pdf.save('openmeteo_report.pdf');
  });
});

/* ==== Names ==== */
const nameOf = (m)=> (m==='era5' ? 'ERA5 Reanalysis' : m);
const labelFor = nameOf;

/* ==== Wind rose helpers ==== */
function degToBin10(d){
  const x = (d==null || isNaN(d)) ? null : ((d % 360) + 360) % 360;
  return (x==null) ? null : Math.floor(x / 10); // 0..35
}
function buildWindSamplesFromSeries(rec){
  const s = [], d = [];
  const sp = rec?.wind_speed_10m || [];
  const dr = rec?.wind_direction_10m || [];
  const n = Math.min(sp.length, dr.length);
  for (let i=0;i<n;i++){
    const v = sp[i], w = dr[i];
    if (v==null || isNaN(v) || w==null || isNaN(w)) continue;
    s.push(Number(v)); d.push(Number(w));
  }
  return { s, d };
}
function concatSamples(list){
  const S=[], D=[];
  list.forEach(({s,d})=>{
    for (let i=0;i<s.length;i++){ S.push(s[i]); D.push(d[i]); }
  });
  return { s:S, d:D };
}
const BIN_SIZE = 2;

function binWindsCustom(speeds, dirs){
  // 36 direction bins (10° each), and fixed TWS bins from TWS_BINS
  const counts = Array.from({length:36}, () => Array.from({length:TWS_BINS.length}, ()=>0));
  const dirTotals = new Array(36).fill(0);

  for (let i = 0; i < speeds.length; i++){
    const s = speeds[i], d = dirs[i];
    const bDir = degToBin10(d);
    if (bDir == null) continue;
    const bSpd = twsBinIndex(s);
    counts[bDir][bSpd] += 1;
    dirTotals[bDir] += 1;
  }

  // Rose spokes centered at 5°, 15°, … (same as your current labels)
  const dirLabels = Array.from({length:36}, (_,i)=> i*10 + 5);
  return { counts, dirTotals, speedBins: TWS_BIN_LABELS, dirLabels };
}

function computeWindStats(speeds, dirs){
  const n = speeds.length;
  if (!n) return { meanTws:null, calmPct:null, peakPct:null, peakDir:null };
  const calm = speeds.filter(v => v < 4).length;
  const calmPct = 100 * calm / n;
  const meanTws = speeds.reduce((a,b)=>a+b,0) / n;
  const bins = new Array(36).fill(0);
  for (let i=0;i<n;i++){
    const b = degToBin10(dirs[i]); if (b!=null) bins[b]++;
  }
  let peakIdx = 0; for (let i=1;i<36;i++) if (bins[i] > bins[peakIdx]) peakIdx = i;
  const peakCnt = bins[peakIdx]; const peakPct = 100 * peakCnt / n;
  const peakDir = (peakIdx*10 + 5) % 360;
  return { meanTws, calmPct, peakPct, peakDir };
}

function makeWindRoseTraces(counts, speedBins, dirLabels){
  const traces = [];
  for (let sb = 0; sb < speedBins.length; sb++){
    const r = counts.map(row => row[sb] || 0);
    if (!r.some(v => v > 0)) continue;
    traces.push({
      type: 'barpolar',
      r,
      theta: dirLabels,
      name: speedBins[sb],
      hovertemplate: 'Dir %{theta}°<br>%{r:.1f}%<br>' + speedBins[sb] + '<extra></extra>',
      marker: { color: TWS_COLOURS[sb] }
    });
  }
  return traces;
}

function formatPct(x){ return (x==null) ? '—' : `${x.toFixed(1)}%`; }
function formatKn(x){ return (x==null) ? '—' : `${x.toFixed(1)} kt`; }
function formatDeg(x){ return (x==null) ? '—' : `${Math.round(x)}°`; }

/* ==== Run ==== */
document.getElementById('runBtn').addEventListener('click', run);

async function run(){
  const days = Math.max(1, Math.min(10, parseInt(document.getElementById('days').value || '5')));
  if (!markers.length) { alert('Add at least one location by clicking the map.'); return; }

  const selectedModels = [...document.querySelectorAll('.model:checked')].map(x => x.value);
  if (!selectedModels.length && !document.getElementById('era5_toggle').checked) {
    alert('Select at least one forecast model or turn on ERA5.'); return;
  }

  const surfaceVars = [...document.querySelectorAll('.var:checked')].map(x => x.value);
  const levels = [...document.querySelectorAll('.pl:checked')].map(x => parseInt(x.value));
  const hourly = buildHourlyVars(surfaceVars).concat(buildPressureLevelVars(levels));
  const includeMarine = document.getElementById('marine_swh').checked;

  const era5On   = document.getElementById('era5_toggle').checked;
  const eraStart = document.getElementById('era5_start').value || '';
  const eraEnd   = document.getElementById('era5_end').value || '';

  const todEnabled = document.getElementById('tod_enable').checked;
  const todFrom    = document.getElementById('tod_from').value;
  const todTo      = document.getElementById('tod_to').value;
  const todFromMin = hhmmToMin(todFrom);
  const todToMin   = hhmmToMin(todTo);

  const eraYearsSelected = readSelectedEraYears();
  const eraMonthsMap = readSelectedEraMonthsMap();

  function countEraMonthRequests(){
    if (!era5On) return 0;
    if (!eraStart || !eraEnd) return 0;
    if (!eraYearsSelected.length) return 1;
    let c = 0;
    eraYearsSelected.forEach(y=>{
      const ms = eraMonthsMap.get(y) || [];
      c += (ms.length ? ms.length : 0);
    });
    return (c === 0) ? 0 : c;
  }

  // Progress
  const prog = document.getElementById('progress');
  const bar  = document.getElementById('progressBar');
  const ptxt = document.getElementById('progressText');
  const totalCalls = (markers.length * selectedModels.length)
                   + (includeMarine ? markers.length : 0)
                   + (era5On ? markers.length * Math.max(1, countEraMonthRequests()) : 0);
  let doneCalls = 0;
  function setProgress(){ const pct = totalCalls ? Math.round(100 * doneCalls / totalCalls) : 0; bar.style.width = pct + '%'; ptxt.textContent = `Downloading models: ${doneCalls}/${totalCalls} (${pct}%)`; }
  function inc(){ doneCalls++; setProgress(); }
  prog.style.display = 'block'; doneCalls = 0; setProgress();

  tabBar.innerHTML = ''; tabContent.innerHTML = ''; for (const k in XLSX_SHEETS) delete XLSX_SHEETS[k];
  const createdPanes = [];

  for (const loc of markers){
    try {
      const pane = addTab(loc);
      const locContainer = document.createElement('div');
      locContainer.className = 'panel';
      locContainer.innerHTML = `<h2>Location #${loc.id} — ${loc.lat.toFixed(3)}, ${loc.lon.toFixed(3)}</h2>`;
      pane.appendChild(locContainer);

      const statusBar = document.createElement('div');
      statusBar.className = 'small'; statusBar.style.margin = '4px 0 8px 0'; statusBar.id = `status_${loc.id}`;
      locContainer.appendChild(statusBar);

      const chartsGrid = document.createElement('div'); chartsGrid.className = 'grid'; locContainer.appendChild(chartsGrid);
      const chartIds = ['TWS','TWD','RAIN','T2M','PMSL','SWH'].map(k => `chart_${loc.id}_${k}`);
      paneCharts[loc.id] = chartIds.map(id => id);
      chartIds.forEach(id => {
        const div = document.createElement('div');
        div.className = 'card'; div.style.minHeight = '280px';
        div.innerHTML = `<div class='small muted' style='margin-bottom:6px'>${id.split('_').pop()}</div><div id='${id}' style='height:260px'></div>`;
        chartsGrid.appendChild(div);
      });

      /* --- Vertical Profile + BLH box (already above tables) --- */
      const profileWrap = document.createElement('div');
      profileWrap.className = 'card';
      profileWrap.style.marginTop = '12px';
      profileWrap.innerHTML = `
        <div class='section-title'>Vertical Profile — TWS & Temp vs Pressure + Boundary Layer Height (GFS)</div>
        <div class='row small'>
          <label>Time index: <input id='prof_idx_${loc.id}' type='number' min='0' value='0' style='width:80px'></label>
          <span class='muted'>Start at 0 for first forecast hour.</span>
        </div>
        <div class="profile-row">
          <div id='profile_left_${loc.id}'  class='profile-left'></div>
          <div id='profile_blh_${loc.id}' class='profile-right'>
            <div class='small muted' style="margin-bottom:6px">Boundary Layer Height — GFS</div>
            <div id='blh_value_${loc.id}' style="font-size:32px; font-weight:700;">—</div>
            <div class="small muted">m AGL (boundary_layer_height)</div>
            <div class="small muted" id='blh_meta_${loc.id}'></div>
          </div>
        </div>`;
      locContainer.appendChild(profileWrap);
      paneCharts[loc.id].push(`profile_left_${loc.id}`);

      /* --- Wind Rose section MOVED ABOVE TABLES --- */
      const roseCard = document.createElement('div');
      roseCard.className = 'card';
      roseCard.style.marginTop = '12px';
      const roseSelectId = `rose_sel_${loc.id}`;
      const rosePlotId   = `rose_plot_${loc.id}`;
	  paneCharts[loc.id].push(rosePlotId);
      const roseTblId    = `rose_tbl_${loc.id}`;
      const modelOptions = []; // fill after data load
      roseCard.innerHTML = `
        <div class='section-title'>Wind Rose (10° bins, TWS bins as per tables) & Summary</div>
        <div class='row small' style="align-items:center; gap:12px;">
          <label>Dataset:
            <select id="${roseSelectId}"></select>
          </label>
          <span class="muted">Calm threshold: &lt; 4 kt</span>
        </div>
        <div class="grid" style="margin-top:8px;">
          <div id="${rosePlotId}" style="min-height:360px;"></div>
          <div>
            <table style="width:100%; font-size:12px;">
              <thead><tr><th style="text-align:left;">Metric</th><th style="text-align:right;">Value</th></tr></thead>
              <tbody id="${roseTblId}">
                <tr><td>Mean TWS</td><td style="text-align:right;">—</td></tr>
                <tr><td>Peak frequency</td><td style="text-align:right;">—</td></tr>
                <tr><td>% Calm (&lt;4 kt)</td><td style="text-align:right;">—</td></tr>
                <tr><td>Peak TWD (dir bin)</td><td style="text-align:right;">—</td></tr>
              </tbody>
            </table>
          </div>
        </div>`;
      locContainer.appendChild(roseCard);

      const modelSeries = {};
      const modelStatus = {};

      // -------- Forecast models loop --------
      for (const mdl of selectedModels){
        try{
          const url = new URL('https://api.open-meteo.com/v1/forecast');
          url.searchParams.set('latitude', loc.lat);
          url.searchParams.set('longitude', loc.lon);
          url.searchParams.set('forecast_days', days);
          url.searchParams.set('timezone', 'auto');
          url.searchParams.set('models', mdl);
          url.searchParams.set('temperature_unit', 'celsius');
          url.searchParams.set('wind_speed_unit', 'kn');
          url.searchParams.set('precipitation_unit', 'mm');
          url.searchParams.set('pressure_unit', 'hPa');
          url.searchParams.set('hourly', hourly.join(','));

          const res = await fetch(url.toString());
          const js = await res.json();
          inc();

          if (!js || !js.hourly || !js.hourly.time || !js.hourly.time.length){
            modelStatus[mdl] = 'no'; continue;
          }

          const h = js.hourly;
          const rec = {
            time: h.time || [],
            wind_speed_10m: h.wind_speed_10m || [],
            wind_direction_10m: h.wind_direction_10m || [],
            temperature_2m: h.temperature_2m || [],
            precipitation: h.precipitation || h.rain || [],
            wind_gusts_10m: h.wind_gusts_10m || [],
            pressure_msl: h.pressure_msl || [],
            cloud_cover: h.cloud_cover || h.cloudcover || [],
            boundary_layer_height: h.boundary_layer_height || h.pbl_height || [],
            pl: {}
          };
          for (const p of levels){
            const ws = h[`windspeed_${p}hPa`]     || h[`wind_speed_${p}hPa`]      || [];
            const wd = h[`winddirection_${p}hPa`] || h[`wind_direction_${p}hPa`]  || [];
            const tt = h[`temperature_${p}hPa`]   || [];
            rec.pl[p] = { ws, wd, tt };
          }

          if (todEnabled && todFromMin!=null && todToMin!=null){
            const mask = buildTodIndexMask(rec.time, todFromMin, todToMin);
            modelSeries[mdl] = applyMaskToRecord(rec, mask);
          } else {
            modelSeries[mdl] = rec;
          }
          modelStatus[mdl] = 'ok';
        } catch(e){
          console.error('Model fetch failed', mdl, e);
          inc(); modelStatus[mdl] = 'err';
        }
      }

      // -------- ERA5 (per year/month) --------
      if (era5On){
        try{
          if (!eraStart || !eraEnd) throw new Error('Select start and end dates for ERA5.');

          const yearList = eraYearsSelected.length ? eraYearsSelected : [];
          const reqRanges = [];

          if (yearList.length){
            const sY = parseInt(eraStart.slice(0,4),10);
            const eY = parseInt(eraEnd.slice(0,4),10);
            for (const Y of yearList){
              if (Y < sY || Y > eY) continue;
              const months = eraMonthsMap.get(Y) || [];
              const monthsToUse = months.length ? months : [];
              for (const M of monthsToUse){
                const mStart = `${Y}-${String(M).padStart(2,'0')}-01`;
                const mEnd   = `${Y}-${String(M).padStart(2,'0')}-${String(lastDayOfMonth(Y,M)).padStart(2,'0')}`;
                const rngStart = (mStart < eraStart) ? eraStart : mStart;
                const rngEnd   = (mEnd   > eraEnd)   ? eraEnd   : mEnd;
                if (rngEnd >= rngStart) reqRanges.push([rngStart, rngEnd]);
              }
            }
            if (!reqRanges.length) reqRanges.push([eraStart, eraEnd]);
          } else {
            reqRanges.push([eraStart, eraEnd]);
          }

          const acc = {
            time: [],
            wind_speed_10m: [],
            wind_direction_10m: [],
            temperature_2m: [],
            precipitation: [],
            wind_gusts_10m: [],
            pressure_msl: [],
            cloud_cover: [],
            boundary_layer_height: [],
            pl: {}
          };
          for (const p of levels){ acc.pl[p] = { ws:[], wd:[], tt:[] }; }

          for (const [rngStart, rngEnd] of reqRanges){
            const era = new URL('https://archive-api.open-meteo.com/v1/era5');
            era.searchParams.set('latitude',  loc.lat);
            era.searchParams.set('longitude', loc.lon);
            era.searchParams.set('start_date', rngStart);
            era.searchParams.set('end_date',   rngEnd);
            era.searchParams.set('timezone',   'auto');
            era.searchParams.set('temperature_unit', 'celsius');
            era.searchParams.set('wind_speed_unit',  'kn');
            era.searchParams.set('precipitation_unit','mm');
            era.searchParams.set('pressure_unit', 'hPa');
            era.searchParams.set('hourly', hourly.join(','));

            if (todEnabled && todFrom && todTo && rngStart === rngEnd){
              const [startISO, endISO] = contiguousIsoRangeIfSingleDay(rngStart, todFrom, todTo);
              maybeApplyHourWindow(era, startISO, endISO);
            }

            const r = await fetch(era.toString());
            const js = await r.json();
            inc();

            if (!js?.hourly?.time?.length) continue;
            const h = js.hourly;

            acc.time.push(...h.time);
            acc.wind_speed_10m.push(...(h.wind_speed_10m || []));
            acc.wind_direction_10m.push(...(h.wind_direction_10m || []));
            acc.temperature_2m.push(...(h.temperature_2m || []));
            acc.precipitation.push(...(h.precipitation || h.rain || []));
            acc.wind_gusts_10m.push(...(h.wind_gusts_10m || []));
            acc.pressure_msl.push(...(h.pressure_msl || []));
            acc.cloud_cover.push(...(h.cloud_cover || h.cloudcover || []));
            acc.boundary_layer_height.push(...(h.boundary_layer_height || h.pbl_height || []));

            for (const p of levels){
              const ws = h[`windspeed_${p}hPa`]     || h[`wind_speed_${p}hPa`]      || [];
              const wd = h[`winddirection_${p}hPa`] || h[`wind_direction_${p}hPa`]  || [];
              const tt = h[`temperature_${p}hPa`]   || [];
              acc.pl[p].ws.push(...ws);
              acc.pl[p].wd.push(...wd);
              acc.pl[p].tt.push(...tt);
            }
          }

          if (!acc.time.length){
            modelStatus['era5'] = 'no';
          } else {
            const idx = acc.time.map((t,i)=>({t,i})).sort((a,b)=> (a.t < b.t ? -1 : a.t > b.t ? 1 : a.i - b.i));
            const reorder = (arr)=> idx.map(o => arr[o.i]);
            const eraRec = {
              time: reorder(acc.time),
              wind_speed_10m: reorder(acc.wind_speed_10m),
              wind_direction_10m: reorder(acc.wind_direction_10m),
              temperature_2m: reorder(acc.temperature_2m),
              precipitation: reorder(acc.precipitation),
              wind_gusts_10m: reorder(acc.wind_gusts_10m),
              pressure_msl: reorder(acc.pressure_msl),
              cloud_cover: reorder(acc.cloud_cover),
              boundary_layer_height: reorder(acc.boundary_layer_height),
              pl: {}
            };
            for (const p of levels){
              eraRec.pl[p] = {
                ws: reorder(acc.pl[p].ws),
                wd: reorder(acc.pl[p].wd),
                tt: reorder(acc.pl[p].tt),
              };
            }
            if (todEnabled && todFromMin!=null && todToMin!=null){
              const mask = buildTodIndexMask(eraRec.time, todFromMin, todToMin);
              modelSeries['era5'] = applyMaskToRecord(eraRec, mask);
            } else {
              modelSeries['era5'] = eraRec;
            }
            modelStatus['era5'] = 'ok';
          }
        } catch(e){
          console.error('ERA5 fetch failed', e);
          inc(); modelStatus['era5'] = 'err';
        }
      }

      // -------- Marine (optional) --------
      if (includeMarine){
        try {
          const mu = new URL('https://marine-api.open-meteo.com/v1/marine');
          mu.searchParams.set('latitude', loc.lat);
          mu.searchParams.set('longitude', loc.lon);
          mu.searchParams.set('hourly', 'wave_height');
          mu.searchParams.set('forecast_days', Math.min(days,7));
          const mres = await fetch(mu.toString());
          const mjs = await mres.json();
          inc();
          const wave_time   = (mjs.hourly && mjs.hourly.time) ? mjs.hourly.time : null;
          const wave_height = (mjs.hourly && mjs.hourly.wave_height) ? mjs.hourly.wave_height : null;
          if (wave_height){
            Object.values(modelSeries).forEach(rec => { rec.wave_time = wave_time || rec.time; rec.wave_height = wave_height; });
          }
        } catch (e){
          console.warn('Marine failed', e);
          inc();
        }
      }

      // ---- Status chips ----
      const statusModels = [...Object.keys(modelStatus)];
      const statusHtml = statusModels.map(mdl => {
        const st = modelStatus[mdl] || 'no';
        const theCls = (st === 'ok') ? 'ok' : (st === 'err' ? 'err' : 'no');
        const text = (st === 'ok') ? '✓ loaded' : (st === 'err' ? '✕ failed' : '– no coverage');
        return `<span class="status-chip ${theCls}">${labelFor(mdl)}<span>${text}</span></span>`;
      }).join('');
      statusBar.innerHTML = statusHtml || '<span class="small muted">No model responses.</span>';

      // ---- Charts ----
      const modelsWithData = Object.keys(modelSeries);
      function makeTraces(varKey, label){
        const traces = [];
        modelsWithData.forEach(mdl => {
          const rec = modelSeries[mdl]; const arr = rec && rec[varKey];
          if (!arr || !arr.length) return;
          traces.push({ x: rec.time, y: arr, name: nameOf(mdl), mode: 'lines',
            line: { width: 2 }, hovertemplate: `%{x}<br>${label}: %{y}<extra>${nameOf(mdl)}</extra>` });
        });
        return traces;
      }
      renderPlotOrMsg(`chart_${loc.id}_TWS`,  makeTraces('wind_speed_10m','TWS (kn)'),   layout('True Wind Speed (10 m, kn)'));
      renderPlotOrMsg(`chart_${loc.id}_TWD`,  makeTraces('wind_direction_10m','TWD (°)'), layout('True Wind Direction (°)'));
      renderPlotOrMsg(`chart_${loc.id}_PMSL`, makeTraces('pressure_msl','MSLP (hPa)'),   layoutPmsl('Sea-level Pressure (hPa)'));
      renderPlotOrMsg(`chart_${loc.id}_RAIN`, makeTraces('precipitation','Precip (mm/hr)'), layout('Precipitation (mm/hr)'));
      renderPlotOrMsg(`chart_${loc.id}_T2M`,  makeTraces('temperature_2m','T2m (°C)'),  layout('Air Temperature (°C)'));

      const waveTraces = [];
      modelsWithData.forEach(mdl => {
        const rec = modelSeries[mdl];
        if (rec && rec.wave_height){
          waveTraces.push({ x: rec.wave_time || rec.time, y: rec.wave_height, name: nameOf(mdl)+' (marine)', mode:'lines', line:{width:2} });
        }
      });
      renderPlotOrMsg(`chart_${loc.id}_SWH`,  waveTraces, layout('Significant Wave Height (m)'));

      // ---- Wind Rose render (populate options then draw) ----
      const modelOptionsNow = Object.keys(modelSeries);
      const sel = document.getElementById(roseSelectId);
      if (sel){
        const selectHtml = [`<option value="__all__">All models combined</option>`]
          .concat(modelOptionsNow.map(m => `<option value="${m}">${nameOf(m)}</option>`)).join('');
        sel.innerHTML = selectHtml;

        function renderRose(choice){
          let samples;
          if (choice === '__all__'){
            const list = Object.keys(modelSeries).map(k => buildWindSamplesFromSeries(modelSeries[k]));
            samples = concatSamples(list);
          } else {
            samples = buildWindSamplesFromSeries(modelSeries[choice]);
          }
          const { s, d } = samples;

          const stats = computeWindStats(s, d);
          const tbl = document.getElementById(roseTblId);
          if (tbl){
            tbl.innerHTML = `
              <tr><td>Mean TWS</td><td style="text-align:right;">${formatKn(stats.meanTws)}</td></tr>
              <tr><td>Peak frequency</td><td style="text-align:right;">${formatPct(stats.peakPct)}</td></tr>
              <tr><td>% Calm (&lt;4 kt)</td><td style="text-align:right;">${formatPct(stats.calmPct)}</td></tr>
              <tr><td>Peak TWD (dir bin)</td><td style="text-align:right;">${formatDeg(stats.peakDir)}</td></tr>
            `;
          }

          const { counts, dirTotals, speedBins, dirLabels } = binWindsCustom(s, d);

          // normalize to % of total samples
          const total = s.length || 1;
          for (let di = 0; di < 36; di++){
            for (let sb = 0; sb < speedBins.length; sb++){
              counts[di][sb] = 100 * counts[di][sb] / total;
            }
            dirTotals[di] = 100 * dirTotals[di] / total;
          }

          const traces = makeWindRoseTraces(counts, speedBins, dirLabels);

          const roseLayout = {
            ...BASE_PLOTLY_LAYOUT,
            title: { ...BASE_PLOTLY_LAYOUT.title, text: 'Wind Rose (% of samples)' },
            margin: { l: 40, r: 40, t: 54, b: 40 },
            polar: {
              bgcolor: '#0f1420',
              angularaxis: {
                direction: "clockwise",
                rotation: 90,
                tickmode: 'array',
                tickvals: [0,90,180,270],
                ticktext: ['N','E','S','W']
              },
              radialaxis: {
                ticksuffix: '%',
                showline: false,
                gridcolor: '#1f2636'
              }
            },
            barmode: 'stack',
            showlegend: true,
            legend: { orientation: 'h', x: 0, y: -0.15 }
          };

          const el = document.getElementById(rosePlotId);
          if (!s.length){
            el.innerHTML = "<div class='small muted'>No wind data in the current filters to build a wind rose.</div>";
            return;
          }
          Plotly.newPlot(rosePlotId, traces, roseLayout, PLOTLY_CONFIG);
        }

        sel.addEventListener('change', () => renderRose(sel.value));
        const defaultChoice = (Object.keys(modelSeries).length > 1) ? '__all__' : Object.keys(modelSeries)[0];
        sel.value = defaultChoice || '__all__';
        renderRose(sel.value);
      }

      // ---- Tables (now below both the vertical profile and wind rose) ----
      const modelsWithDataTbl = Object.keys(modelSeries);
      const timesSorted = buildTimesUnion(modelSeries, modelsWithDataTbl);

      const tablesWrap = document.createElement('div');
      tablesWrap.className = 'grid'; tablesWrap.style.marginTop = '12px';

      const twsCard = document.createElement('div'); twsCard.className = 'card';
      twsCard.innerHTML = `
        <div class='section-title'>TWS (kn) — by Time × Model</div>
        <div class="legend"><span class="badge">TWS bins: &lt;5 blue, 5–10 green, 10–15 yellow, 15–20 orange, 20–25 red, 25–30 maroon, &gt;30 purple</span></div>
        <div id="tbl_tws_${loc.id}"></div>`;
      tablesWrap.appendChild(twsCard);

      const twdCard = document.createElement('div'); twdCard.className = 'card';
      twdCard.innerHTML = `
        <div class='section-title'>TWD (°) — by Time × Model</div>
        <div class="legend"><span class="badge">Color vs model's mean: left (−) = red, right (+) = green</span></div>
        <div id="tbl_twd_${loc.id}"></div>`;
      tablesWrap.appendChild(twdCard);

      const t2mCard = document.createElement('div'); t2mCard.className = 'card';
      t2mCard.innerHTML = `
        <div class='section-title'>Air Temperature (°C) — by Time × Model</div>
        <div class="legend"><span class="badge">Same bins as TWS: &lt;5 blue … &gt;30 purple</span></div>
        <div id="tbl_t2m_${loc.id}"></div>`;
      tablesWrap.appendChild(t2mCard);

      locContainer.appendChild(tablesWrap);

      const idxMap = {};
      modelsWithDataTbl.forEach(mdl => {
        const tArr = modelSeries[mdl].time || [];
        const idx = new Map(); tArr.forEach((t,i)=>idx.set(t,i)); idxMap[mdl] = idx;
      });

      const meanDir = {};
      modelsWithDataTbl.forEach(mdl => {
        const arr = modelSeries[mdl].wind_direction_10m || [];
        meanDir[mdl] = circMeanDeg(arr);
      });

      function twsGetter(ts, mdl){ const rec = modelSeries[mdl]; const i = idxMap[mdl].get(ts); if (i==null) return ''; const v = rec.wind_speed_10m[i]; return (v==null)? '' : v; }
      function twsColor(v){ const k = twsBinIndex(Number(v)); return TWS_COLOURS[k] || '#444'; }
      function t2mGetter(ts, mdl){ const rec = modelSeries[mdl]; const i = idxMap[mdl].get(ts); if (i==null) return ''; const v = rec.temperature_2m[i]; return (v==null)? '' : v; }
      function t2mColor(v){ return colorForTempC(Number(v)); }
      function twdGetter(ts, mdl){ const rec = modelSeries[mdl]; const i = idxMap[mdl].get(ts); if (i==null) return ''; const v = rec.wind_direction_10m[i]; return (v==null)? '' : v; }
      function twdColor(v, ts, mdl){ const mean = meanDir[mdl]; if (v==='' || mean==null) return null; const d = angDiff(Number(v), mean); const mag = Math.min(Math.abs(d)/90, 1); const alpha = 0.25 + 0.45*mag; return d >= 0 ? `rgba(40, 167, 69, ${alpha})` : `rgba(220, 53, 69, ${alpha})`; }
      function degFmt(v){ return (v===''? '' : Math.round(Number(v)) + '°'); }

      renderVarMatrixTable(document.getElementById(`tbl_tws_${loc.id}`), timesSorted, modelsWithDataTbl, modelSeries, twsGetter, twsColor, v=>v===''?'':Number(v).toFixed(1));
      renderVarMatrixTable(document.getElementById(`tbl_twd_${loc.id}`), timesSorted, modelsWithDataTbl, modelSeries, twdGetter, twdColor, degFmt);
      renderVarMatrixTable(document.getElementById(`tbl_t2m_${loc.id}`), timesSorted, modelsWithDataTbl, modelSeries, t2mGetter, t2mColor, v=>v===''?'':Number(v).toFixed(1));

      // --- Vertical profile logic (and BLH update from GFS only) ---
      function drawProfile(){
        const ti = parseInt(document.getElementById(`prof_idx_${loc.id}`).value || '0');
        const modelsWithDataProf = Object.keys(modelSeries).filter(m => modelSeries[m]?.time?.length);

        const leftTraces = [];
        modelsWithDataProf.forEach(mdl => {
          const rec = modelSeries[mdl];
          const yP=[], ws=[], tt=[];
          Object.keys(rec.pl).forEach(p => {
            const arr = rec.pl[p]; if (!arr) return;
            const vws = (arr.ws||[])[ti]; const vtt = (arr.tt||[])[ti];
            if (vws==null && vtt==null) return;
            yP.push(parseInt(p)); ws.push(vws ?? null); tt.push(vtt ?? null);
          });
          if (yP.length){
            leftTraces.push({ x: ws, y: yP, name: mdl+' TWS',  mode:'lines+markers', xaxis:'x',  yaxis:'y',
                              marker:{size:4}, line:{width:1.5},
                              hovertemplate:'%{y} hPa<br>TWS %{x:.1f} kn<extra>'+mdl+'</extra>' });
            leftTraces.push({ x: tt, y: yP, name: mdl+' Temp', mode:'lines+markers', xaxis:'x2', yaxis:'y',
                              marker:{size:4}, line:{width:1.5},
                              hovertemplate:'%{y} hPa<br>T %{x:.1f} °C<extra>'+mdl+'</extra>' });
          }
        });
        const leftLayout = {
          ...BASE_PLOTLY_LAYOUT,
          height: 320,
          title: { ...BASE_PLOTLY_LAYOUT.title, text: 'TWS (bottom) & Temp (top) vs Pressure' },
          margin: { l: 56, r: 24, t: 54, b: 76 },
          yaxis:  { ...BASE_PLOTLY_LAYOUT.yaxis, title:'Pressure (hPa)', autorange:'reversed' },
          xaxis:  { type:'linear', title:'TWS (kn)', automargin:true, gridcolor:'#1f2636', linecolor:'#2a3347', ticks:'outside', tickcolor:'#2a3347' },
          xaxis2: { type:'linear', overlaying:'x', side:'top', title:'Temp (°C)', zeroline:false, showgrid:false }
        };

        renderPlotOrMsg(`profile_left_${loc.id}`, leftTraces, leftLayout);

        // --- BLH box (GFS only) ---
        const gfs = modelSeries['gfs_seamless'];
        const valEl = document.getElementById(`blh_value_${loc.id}`);
        const metaEl = document.getElementById(`blh_meta_${loc.id}`);

        if (!gfs) {
          if (valEl) valEl.textContent = '—';
          if (metaEl) metaEl.textContent = 'GFS not loaded.';
          return;
        }

        const blhArr = gfs.boundary_layer_height || [];
        const tArr   = gfs.time || [];
        const blhVal = blhArr[ti];
        const tIso   = tArr[ti];

        if (valEl) valEl.textContent = (blhVal==null || isNaN(blhVal)) ? '—' : `${Math.round(blhVal)} m`;
        if (metaEl) metaEl.textContent = tIso ? `at ${tIso}` : '';
      }

      drawProfile();
      document.getElementById(`prof_idx_${loc.id}`).addEventListener('change', drawProfile);

      // Finish up location
      createdPanes.push(loc.id);

    } catch(err){
      console.error(`Location #${loc.id} rendering failed`, err);
    }
  }

  if (createdPanes.length) activateTab(createdPanes[0]);
  document.getElementById('progressText').textContent += ' — Done';
}

/* ==== Names for export placeholder ==== */
function aoaFromMatrix(timesSorted, models, getter, formatter){
  const header = ['Time', ...models.map(nameOf)];
  const aoa = [header];
  timesSorted.forEach(ts=>{
    const row = [ts];
    models.forEach(m=>{
      const v = getter(ts, m);
      row.push(formatter ? formatter(v) : (v===''?'':Number(v).toFixed(1)));
    });
    aoa.push(row);
  });
  return aoa;
}
</script>
</body>
</html>
